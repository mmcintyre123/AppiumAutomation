'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _appiumSupport = require('appium-support');

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _teen_process = require('teen_process');

var _v8 = require('v8');

var _v82 = _interopRequireDefault(_v8);

// Date-Utils: Polyfills for the Date object
require('date-utils');

var START_TIMEOUT = 10000;
var DEVICE_CONSOLE_PATH = _path2['default'].resolve(__dirname, '..', '..', '..', 'build', 'deviceconsole');
var SYSTEM_LOG_PATH = '/var/log/system.log';

var IOSLog = (function () {
  function IOSLog(opts) {
    _classCallCheck(this, IOSLog);

    this.sim = opts.sim;
    this.udid = opts.udid;
    this.showLogs = !!opts.showLogs;

    this.proc = null;
    this.iosLogStartTime = null;
    this.loggingModeOn = true;
    this.logs = [];
    this.logsSize = this._objectSize(this.logs);
    this.logRow = '';
    this.logIdxSinceLastRequest = -1;

    // method to save the time of the first log
    this.logsStarted = _lodash2['default'].once(function () {
      this.iosLogStartTime = new Date();
    });
  }

  _createClass(IOSLog, [{
    key: 'startCaptureRealDevice',
    value: function startCaptureRealDevice() {
      var spawnEnv, idevicesyslog;
      return _regeneratorRuntime.async(function startCaptureRealDevice$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.loggingModeOn = false;
            spawnEnv = _lodash2['default'].clone(process.env);

            _logger2['default'].debug('Attempting iOS device log capture via libimobiledevice idevicesyslog');
            context$2$0.prev = 3;
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevicesyslog'));

          case 6:
            idevicesyslog = context$2$0.sent;

            _logger2['default'].debug('Found idevicesyslog: \'' + idevicesyslog + '\'');
            this.proc = new _teen_process.SubProcess('idevicesyslog', ['-u', this.udid], { env: spawnEnv });
            context$2$0.next = 18;
            break;

          case 11:
            context$2$0.prev = 11;
            context$2$0.t0 = context$2$0['catch'](3);

            _logger2['default'].warn('Could not capture device log using libimobiledevice idevicesyslog. ' + 'Libimobiledevice is probably not installed');
            _logger2['default'].debug('Attempting iOS device log capture via deviceconsole');
            spawnEnv.PATH = process.env.PATH + ':' + DEVICE_CONSOLE_PATH;
            spawnEnv.DYLD_LIBRARY_PATH = DEVICE_CONSOLE_PATH + ':' + process.env.DYLD_LIBRARY_PATH;
            this.proc = new _teen_process.SubProcess('deviceconsole', ['-u', this.udid], { env: spawnEnv });

          case 18:
            context$2$0.next = 20;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 20:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 11]]);
    }
  }, {
    key: 'startCapture',
    value: function startCapture() {
      var xCodeVersion, logPath, systemLogPath, files, lastModifiedLogPath, lastModifiedLogTime, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, file, mtime;

      return _regeneratorRuntime.async(function startCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.udid) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', this.startCaptureRealDevice());

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(_appiumXcode2['default'].getVersion(true));

          case 4:
            xCodeVersion = context$2$0.sent;
            context$2$0.t0 = _logger2['default'];
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(this.sim.getPlatformVersion());

          case 8:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = 'Starting iOS ' + context$2$0.t1;
            context$2$0.t3 = context$2$0.t2 + ' simulator log capture';
            context$2$0.t0.debug.call(context$2$0.t0, context$2$0.t3);

            if (!(xCodeVersion.major < 5)) {
              context$2$0.next = 17;
              break;
            }

            this.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', SYSTEM_LOG_PATH]);
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 16:
            return context$2$0.abrupt('return');

          case 17:

            // this is xcode 6+
            if (_lodash2['default'].isUndefined(this.sim.udid)) {
              _logger2['default'].errorAndThrow('iOS ' + xCodeVersion.versionString + ' log capture requires a sim udid');
            }

            logPath = this.sim.getLogDir();
            context$2$0.prev = 19;

            if (!(logPath.indexOf('*') >= 0)) {
              context$2$0.next = 23;
              break;
            }

            _logger2['default'].error('Log path has * in it. Unable to start log capture: ' + logPath);
            return context$2$0.abrupt('return');

          case 23:
            systemLogPath = _path2['default'].resolve(logPath, 'system.log');

            _logger2['default'].debug('System log path: ' + systemLogPath);
            context$2$0.next = 27;
            return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(logPath));

          case 27:
            context$2$0.next = 29;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(systemLogPath, 'A new Appium session is about to start!\n', { flag: 'a' }));

          case 29:
            files = undefined;
            context$2$0.prev = 30;
            context$2$0.next = 33;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.glob(systemLogPath));

          case 33:
            files = context$2$0.sent;

            if (!(files.length < 1)) {
              context$2$0.next = 36;
              break;
            }

            throw new Error('Could not start log capture');

          case 36:
            context$2$0.next = 41;
            break;

          case 38:
            context$2$0.prev = 38;
            context$2$0.t4 = context$2$0['catch'](30);

            _logger2['default'].error('Could not start log capture because no iOS ' + ('simulator logs could be found at ' + systemLogPath + '. ') + 'Logging will not be functional for this run');

          case 41:
            lastModifiedLogPath = files[0];
            context$2$0.next = 44;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(lastModifiedLogPath).mtime);

          case 44:
            lastModifiedLogTime = context$2$0.sent;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 48;
            _iterator = _getIterator(files);

          case 50:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 59;
              break;
            }

            file = _step.value;
            context$2$0.next = 54;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(file).mtime);

          case 54:
            mtime = context$2$0.sent;

            if (mtime > lastModifiedLogTime) {
              lastModifiedLogPath = file;
              lastModifiedLogTime = mtime;
            }

          case 56:
            _iteratorNormalCompletion = true;
            context$2$0.next = 50;
            break;

          case 59:
            context$2$0.next = 65;
            break;

          case 61:
            context$2$0.prev = 61;
            context$2$0.t5 = context$2$0['catch'](48);
            _didIteratorError = true;
            _iteratorError = context$2$0.t5;

          case 65:
            context$2$0.prev = 65;
            context$2$0.prev = 66;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 68:
            context$2$0.prev = 68;

            if (!_didIteratorError) {
              context$2$0.next = 71;
              break;
            }

            throw _iteratorError;

          case 71:
            return context$2$0.finish(68);

          case 72:
            return context$2$0.finish(65);

          case 73:
            this.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', lastModifiedLogPath]);
            context$2$0.next = 76;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 76:
            context$2$0.next = 81;
            break;

          case 78:
            context$2$0.prev = 78;
            context$2$0.t6 = context$2$0['catch'](19);

            _logger2['default'].errorAndThrow('System log capture failed: ' + context$2$0.t6.message);

          case 81:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[19, 78], [30, 38], [48, 61, 65, 73], [66,, 68, 72]]);
    }
  }, {
    key: 'finishStartingLogCapture',
    value: function finishStartingLogCapture() {
      var firstLine, sd;
      return _regeneratorRuntime.async(function finishStartingLogCapture$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc) {
              _logger2['default'].errorAndThrow('Could not capture device log');
            }
            firstLine = true;

            this.proc.on('output', function (stdout, stderr) {
              if (stdout) {
                if (firstLine) {
                  if (stdout.substr(-1, 1) === '\n') {
                    // don't store the first line of the log because it came before the sim or device was launched
                    firstLine = false;
                  }
                } else {
                  _this.logRow += stdout;
                  if (stdout.substr(-1, 1) === '\n') {
                    _this.onOutput();
                    _this.logRow = '';
                  }
                }
              }
              if (stderr) {
                _this.onOutput('STDERR');
              }
            });

            sd = function sd(stdout, stderr) {
              if (/execvp\(\)/.test(stderr)) {
                throw new Error('iOS log capture process failed to start');
              }
              return stdout || stderr;
            };

            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.proc.start(sd, START_TIMEOUT));

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stopCapture',
    value: function stopCapture() {
      return _regeneratorRuntime.async(function stopCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Stopping iOS log capture');

            if (!(this.proc && this.proc.isRunning)) {
              context$2$0.next = 12;
              break;
            }

            context$2$0.prev = 2;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGTERM', 1000));

          case 5:
            context$2$0.next = 12;
            break;

          case 7:
            context$2$0.prev = 7;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].error('Cannot stop log capture process. Sending SIGKILL...');
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGKILL'));

          case 12:
            this.proc = null;

          case 13:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: '_objectSize',
    value: function _objectSize(obj) {
      var objectList = [];
      var stack = [obj];
      var bytes = 0;

      while (stack.length) {
        var value = stack.pop();
        if (typeof value === 'boolean') {
          bytes += 4;
        } else if (typeof value === 'string') {
          bytes += value.length * 2;
        } else if (typeof value === 'number') {
          bytes += 8;
        } else if (typeof value === 'object' && objectList.indexOf(value) === -1) {
          objectList.push(value);
          for (var i in value) {
            stack.push(value[i]);
          }
        }
      }
      return bytes;
    }
  }, {
    key: '_appendLog',
    value: function _appendLog(logObj) {
      var heapStats = _v82['default'].getHeapStatistics();
      var heapAvailSize = heapStats.heap_size_limit - heapStats.used_heap_size;
      var logObjSize = this._objectSize(logObj);
      if (logObjSize + this.logsSize >= heapAvailSize / 4) {
        // Shrink log records cache by 25% if its total size is greater than 25% of space
        // potentially available for allocation by NodeJS heap
        _logger2['default'].warn('Shrinking current device logs cache to avoid heap overflow');
        var shrinkToIdx = this.logs.length / 4;
        var shrinkSize = this._objectSize(this.logs.slice(0, shrinkToIdx));
        this.logs = this.logs.slice(shrinkToIdx);
        this.logsSize -= shrinkSize;
        if (this.logIdxSinceLastRequest >= 0) {
          if (this.logIdxSinceLastRequest >= shrinkToIdx) {
            this.logIdxSinceLastRequest -= shrinkToIdx;
          } else {
            this.logIdxSinceLastRequest = 0;
          }
        }
      }
      this.logs.push(logObj);
      this.logsSize += logObjSize;
    }
  }, {
    key: 'onOutput',
    value: function onOutput() {
      var prefix = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      this.logsStarted();

      var logs = this.logRow.split('\n');
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _getIterator(logs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var log = _step2.value;

          if (log) {
            if (!this.loggingModeOn) {
              // figure out if this log row marks the beginning of our log capture or not
              var logRowParts = log.split(/\s+/);
              var logRowDate = new Date(this.iosLogStartTime.getFullYear() + ' ' + logRowParts[0] + ' ' + logRowParts[1] + ' ' + logRowParts[2]);
              if (logRowDate.isAfter(this.iosLogStartTime)) {
                this.loggingModeOn = true;
              }
            }
            if (this.loggingModeOn) {
              var logObj = {
                timestamp: Date.now(),
                level: 'ALL',
                message: log
              };
              this._appendLog(logObj);
              if (this.showLogs) {
                var space = prefix.length > 0 ? ' ' : '';
                _logger2['default'].info('[IOS_SYSLOG_ROW' + space + prefix + '] ' + log);
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'getLogs',
    value: function getLogs() {
      var result;
      return _regeneratorRuntime.async(function getLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!(this.logs.length > 0 && this.logIdxSinceLastRequest < this.logs.length)) {
              context$2$0.next = 5;
              break;
            }

            result = undefined;

            if (this.logIdxSinceLastRequest > 0) {
              result = this.logs.slice(this.logIdxSinceLastRequest);
            } else {
              result = this.logs;
            }
            this.logIdxSinceLastRequest = this.logs.length;
            return context$2$0.abrupt('return', result);

          case 5:
            return context$2$0.abrupt('return', []);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getAllLogs',
    value: function getAllLogs() {
      return _regeneratorRuntime.async(function getAllLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', this.logs);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return IOSLog;
})();

exports['default'] = IOSLog;
module.exports = exports['default'];
// if we have a real device

// otherwise, if we have a simulator...
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXZpY2UtbG9nL2lvcy1sb2cuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztvQkFBaUIsTUFBTTs7OztzQkFDVCxRQUFROzs7O3NCQUNILFVBQVU7Ozs7NkJBQ0YsZ0JBQWdCOzsyQkFDekIsY0FBYzs7Ozs0QkFDTCxjQUFjOztrQkFDMUIsSUFBSTs7Ozs7QUFHbkIsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDOztBQUd0QixJQUFNLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFDNUIsSUFBTSxtQkFBbUIsR0FBRyxrQkFBSyxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztBQUNoRyxJQUFNLGVBQWUsR0FBRyxxQkFBcUIsQ0FBQzs7SUFFeEMsTUFBTTtBQUNFLFdBRFIsTUFBTSxDQUNHLElBQUksRUFBRTswQkFEZixNQUFNOztBQUVSLFFBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNwQixRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDdEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzs7QUFFaEMsUUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsUUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7QUFDNUIsUUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7QUFDMUIsUUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7QUFDZixRQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzVDLFFBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxzQkFBc0IsR0FBRyxDQUFDLENBQUMsQ0FBQzs7O0FBR2pDLFFBQUksQ0FBQyxXQUFXLEdBQUcsb0JBQUUsSUFBSSxDQUFDLFlBQVk7QUFDcEMsVUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0tBQ25DLENBQUMsQ0FBQztHQUNKOztlQWxCRyxNQUFNOztXQW9CbUI7VUFFdkIsUUFBUSxFQUdOLGFBQWE7Ozs7QUFKbkIsZ0JBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO0FBQ3ZCLG9CQUFRLEdBQUcsb0JBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7O0FBQ25DLGdDQUFPLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDOzs7NkNBRXpELGtCQUFHLEtBQUssQ0FBQyxlQUFlLENBQUM7OztBQUEvQyx5QkFBYTs7QUFDakIsZ0NBQU8sS0FBSyw2QkFBMEIsYUFBYSxRQUFJLENBQUM7QUFDeEQsZ0JBQUksQ0FBQyxJQUFJLEdBQUcsNkJBQWUsZUFBZSxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUMsQ0FBQyxDQUFDOzs7Ozs7OztBQUVoRixnQ0FBTyxJQUFJLENBQUMscUVBQXFFLEdBQ3JFLDRDQUE0QyxDQUFDLENBQUM7QUFDMUQsZ0NBQU8sS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7QUFDcEUsb0JBQVEsQ0FBQyxJQUFJLEdBQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFNBQUksbUJBQW1CLEFBQUUsQ0FBQztBQUM3RCxvQkFBUSxDQUFDLGlCQUFpQixHQUFNLG1CQUFtQixTQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEFBQUUsQ0FBQztBQUN2RixnQkFBSSxDQUFDLElBQUksR0FBRyw2QkFBZSxlQUFlLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUMsR0FBRyxFQUFFLFFBQVEsRUFBQyxDQUFDLENBQUM7Ozs7NkNBRTVFLElBQUksQ0FBQyx3QkFBd0IsRUFBRTs7Ozs7OztLQUN0Qzs7O1dBRWtCO1VBS2IsWUFBWSxFQWNaLE9BQU8sRUFNTCxhQUFhLEVBSWIsS0FBSyxFQVlMLG1CQUFtQixFQUNuQixtQkFBbUIsa0ZBQ2QsSUFBSSxFQUNQLEtBQUs7Ozs7O2lCQTNDVCxJQUFJLENBQUMsSUFBSTs7Ozs7Z0RBQ0osSUFBSSxDQUFDLHNCQUFzQixFQUFFOzs7OzZDQUdiLHlCQUFNLFVBQVUsQ0FBQyxJQUFJLENBQUM7OztBQUEzQyx3QkFBWTs7OzZDQUVtQixJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixFQUFFOzs7Ozs7MkJBQXpELEtBQUs7O2tCQUNSLFlBQVksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFBOzs7OztBQUN4QixnQkFBSSxDQUFDLElBQUksR0FBRyw2QkFBZSxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDOzs2Q0FDakUsSUFBSSxDQUFDLHdCQUF3QixFQUFFOzs7Ozs7OztBQUt2QyxnQkFBSSxvQkFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNoQyxrQ0FBTyxhQUFhLFVBQVEsWUFBWSxDQUFDLGFBQWEsc0NBQW1DLENBQUM7YUFDM0Y7O0FBRUcsbUJBQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRTs7O2tCQUU1QixPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQTs7Ozs7QUFDM0IsZ0NBQU8sS0FBSyx5REFBdUQsT0FBTyxDQUFHLENBQUM7Ozs7QUFHNUUseUJBQWEsR0FBRyxrQkFBSyxPQUFPLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQzs7QUFDdkQsZ0NBQU8sS0FBSyx1QkFBcUIsYUFBYSxDQUFHLENBQUM7OzZDQUM1QywyQkFBTyxPQUFPLENBQUM7Ozs7NkNBQ2Ysa0JBQUcsU0FBUyxDQUFDLGFBQWEsRUFBRSwyQ0FBMkMsRUFBRSxFQUFDLElBQUksRUFBRSxHQUFHLEVBQUMsQ0FBQzs7O0FBQ3ZGLGlCQUFLOzs7NkNBRU8sa0JBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQzs7O0FBQXBDLGlCQUFLOztrQkFDRCxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQTs7Ozs7a0JBQ1osSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUM7Ozs7Ozs7Ozs7QUFHaEQsZ0NBQU8sS0FBSyxDQUFDLHVGQUNvQyxhQUFhLFFBQUksZ0RBQ1IsQ0FBQyxDQUFDOzs7QUFHMUQsK0JBQW1CLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQzs7NkNBQ0Ysa0JBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsS0FBSzs7O0FBQTlELCtCQUFtQjs7Ozs7cUNBQ04sS0FBSzs7Ozs7Ozs7QUFBYixnQkFBSTs7NkNBQ08sa0JBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUs7OztBQUFqQyxpQkFBSzs7QUFDVCxnQkFBSSxLQUFLLEdBQUcsbUJBQW1CLEVBQUU7QUFDL0IsaUNBQW1CLEdBQUcsSUFBSSxDQUFDO0FBQzNCLGlDQUFtQixHQUFHLEtBQUssQ0FBQzthQUM3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsZ0JBQUksQ0FBQyxJQUFJLEdBQUcsNkJBQWUsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDOzs2Q0FDckUsSUFBSSxDQUFDLHdCQUF3QixFQUFFOzs7Ozs7Ozs7O0FBRXJDLGdDQUFPLGFBQWEsaUNBQStCLGVBQUksT0FBTyxDQUFHLENBQUM7Ozs7Ozs7S0FFckU7OztXQUU4QjtVQUl6QixTQUFTLEVBcUJULEVBQUU7Ozs7OztBQXhCTixnQkFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7QUFDZCxrQ0FBTyxhQUFhLENBQUMsOEJBQThCLENBQUMsQ0FBQzthQUN0RDtBQUNHLHFCQUFTLEdBQUcsSUFBSTs7QUFDcEIsZ0JBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxVQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUs7QUFDekMsa0JBQUksTUFBTSxFQUFFO0FBQ1Ysb0JBQUksU0FBUyxFQUFFO0FBQ2Isc0JBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7O0FBRWpDLDZCQUFTLEdBQUcsS0FBSyxDQUFDO21CQUNuQjtpQkFDRixNQUFNO0FBQ0wsd0JBQUssTUFBTSxJQUFJLE1BQU0sQ0FBQztBQUN0QixzQkFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUNqQywwQkFBSyxRQUFRLEVBQUUsQ0FBQztBQUNoQiwwQkFBSyxNQUFNLEdBQUcsRUFBRSxDQUFDO21CQUNsQjtpQkFDRjtlQUNGO0FBQ0Qsa0JBQUksTUFBTSxFQUFFO0FBQ1Ysc0JBQUssUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2VBQ3pCO2FBQ0YsQ0FBQyxDQUFDOztBQUVDLGNBQUUsR0FBRyxTQUFMLEVBQUUsQ0FBSSxNQUFNLEVBQUUsTUFBTSxFQUFLO0FBQzNCLGtCQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDN0Isc0JBQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQztlQUM1RDtBQUNELHFCQUFPLE1BQU0sSUFBSSxNQUFNLENBQUM7YUFDekI7Ozs2Q0FDSyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsYUFBYSxDQUFDOzs7Ozs7O0tBQ3pDOzs7V0FFaUI7Ozs7QUFDaEIsZ0NBQU8sS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7O2tCQUNyQyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFBOzs7Ozs7OzZDQUUxQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDOzs7Ozs7Ozs7O0FBRXJDLGdDQUFPLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDOzs2Q0FDOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDOzs7QUFHbkMsZ0JBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7Ozs7O0tBQ2xCOzs7V0FFVyxxQkFBQyxHQUFHLEVBQUU7QUFDaEIsVUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLFVBQUksS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEIsVUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDOztBQUVkLGFBQU8sS0FBSyxDQUFDLE1BQU0sRUFBRTtBQUNuQixZQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDeEIsWUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLEVBQUU7QUFDOUIsZUFBSyxJQUFJLENBQUMsQ0FBQztTQUNaLE1BQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDcEMsZUFBSyxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQzNCLE1BQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDcEMsZUFBSyxJQUFJLENBQUMsQ0FBQztTQUNaLE1BQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUN4RSxvQkFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2QixlQUFLLElBQUksQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUNuQixpQkFBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztXQUN0QjtTQUNGO09BQ0Y7QUFDRCxhQUFPLEtBQUssQ0FBQztLQUNkOzs7V0FFVSxvQkFBQyxNQUFNLEVBQUU7QUFDbEIsVUFBTSxTQUFTLEdBQUcsZ0JBQUcsaUJBQWlCLEVBQUUsQ0FBQztBQUN6QyxVQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQyxjQUFjLENBQUM7QUFDM0UsVUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM1QyxVQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxJQUFJLGFBQWEsR0FBRyxDQUFDLEVBQUU7OztBQUduRCw0QkFBTyxJQUFJLENBQUMsNERBQTRELENBQUMsQ0FBQztBQUMxRSxZQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDekMsWUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUNyRSxZQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3pDLFlBQUksQ0FBQyxRQUFRLElBQUksVUFBVSxDQUFDO0FBQzVCLFlBQUksSUFBSSxDQUFDLHNCQUFzQixJQUFJLENBQUMsRUFBRTtBQUNwQyxjQUFJLElBQUksQ0FBQyxzQkFBc0IsSUFBSSxXQUFXLEVBQUU7QUFDOUMsZ0JBQUksQ0FBQyxzQkFBc0IsSUFBSSxXQUFXLENBQUM7V0FDNUMsTUFBTTtBQUNMLGdCQUFJLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxDQUFDO1dBQ2pDO1NBQ0Y7T0FDRjtBQUNELFVBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZCLFVBQUksQ0FBQyxRQUFRLElBQUksVUFBVSxDQUFDO0tBQzdCOzs7V0FFUSxvQkFBYztVQUFiLE1BQU0seURBQUcsRUFBRTs7QUFDbkIsVUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDOztBQUVuQixVQUFJLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzs7Ozs7O0FBQ25DLDJDQUFnQixJQUFJLGlIQUFFO2NBQWIsR0FBRzs7QUFDVixjQUFJLEdBQUcsRUFBRTtBQUNQLGdCQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTs7QUFFdkIsa0JBQUksV0FBVyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkMsa0JBQUksVUFBVSxHQUFHLElBQUksSUFBSSxDQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFNBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsU0FBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUcsQ0FBQztBQUN6SCxrQkFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRTtBQUM1QyxvQkFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7ZUFDM0I7YUFDRjtBQUNELGdCQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7QUFDdEIsa0JBQUksTUFBTSxHQUFHO0FBQ1gseUJBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO0FBQ3JCLHFCQUFLLEVBQUUsS0FBSztBQUNaLHVCQUFPLEVBQUUsR0FBRztlQUNiLENBQUM7QUFDRixrQkFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN4QixrQkFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2pCLG9CQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ3pDLG9DQUFPLElBQUkscUJBQW1CLEtBQUssR0FBRyxNQUFNLFVBQUssR0FBRyxDQUFHLENBQUM7ZUFDekQ7YUFDRjtXQUNGO1NBQ0Y7Ozs7Ozs7Ozs7Ozs7OztLQUNGOzs7V0FFYTtVQUVOLE1BQU07Ozs7a0JBRFIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQTs7Ozs7QUFDcEUsa0JBQU07O0FBQ1YsZ0JBQUksSUFBSSxDQUFDLHNCQUFzQixHQUFHLENBQUMsRUFBRTtBQUNuQyxvQkFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO2FBQ3ZELE1BQU07QUFDTCxvQkFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDcEI7QUFDRCxnQkFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO2dEQUN4QyxNQUFNOzs7Z0RBRVIsRUFBRTs7Ozs7OztLQUNWOzs7V0FFZ0I7Ozs7Z0RBQ1IsSUFBSSxDQUFDLElBQUk7Ozs7Ozs7S0FDakI7OztTQTVPRyxNQUFNOzs7cUJBK09HLE1BQU0iLCJmaWxlIjoibGliL2RldmljZS1sb2cvaW9zLWxvZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgZnMsIG1rZGlycCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB4Y29kZSBmcm9tICdhcHBpdW0teGNvZGUnO1xuaW1wb3J0IHsgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgdjggZnJvbSAndjgnO1xuXG4vLyBEYXRlLVV0aWxzOiBQb2x5ZmlsbHMgZm9yIHRoZSBEYXRlIG9iamVjdFxucmVxdWlyZSgnZGF0ZS11dGlscycpO1xuXG5cbmNvbnN0IFNUQVJUX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFVklDRV9DT05TT0xFX1BBVEggPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAnYnVpbGQnLCAnZGV2aWNlY29uc29sZScpO1xuY29uc3QgU1lTVEVNX0xPR19QQVRIID0gJy92YXIvbG9nL3N5c3RlbS5sb2cnO1xuXG5jbGFzcyBJT1NMb2cge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMuc2ltID0gb3B0cy5zaW07XG4gICAgdGhpcy51ZGlkID0gb3B0cy51ZGlkO1xuICAgIHRoaXMuc2hvd0xvZ3MgPSAhIW9wdHMuc2hvd0xvZ3M7XG5cbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMuaW9zTG9nU3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmxvZ2dpbmdNb2RlT24gPSB0cnVlO1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIHRoaXMubG9nc1NpemUgPSB0aGlzLl9vYmplY3RTaXplKHRoaXMubG9ncyk7XG4gICAgdGhpcy5sb2dSb3cgPSAnJztcbiAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPSAtMTtcblxuICAgIC8vIG1ldGhvZCB0byBzYXZlIHRoZSB0aW1lIG9mIHRoZSBmaXJzdCBsb2dcbiAgICB0aGlzLmxvZ3NTdGFydGVkID0gXy5vbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaW9zTG9nU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZVJlYWxEZXZpY2UgKCkge1xuICAgIHRoaXMubG9nZ2luZ01vZGVPbiA9IGZhbHNlO1xuICAgIGxldCBzcGF3bkVudiA9IF8uY2xvbmUocHJvY2Vzcy5lbnYpO1xuICAgIGxvZ2dlci5kZWJ1ZygnQXR0ZW1wdGluZyBpT1MgZGV2aWNlIGxvZyBjYXB0dXJlIHZpYSBsaWJpbW9iaWxlZGV2aWNlIGlkZXZpY2VzeXNsb2cnKTtcbiAgICB0cnkge1xuICAgICAgbGV0IGlkZXZpY2VzeXNsb2cgPSBhd2FpdCBmcy53aGljaCgnaWRldmljZXN5c2xvZycpO1xuICAgICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBpZGV2aWNlc3lzbG9nOiAnJHtpZGV2aWNlc3lzbG9nfSdgKTtcbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKCdpZGV2aWNlc3lzbG9nJywgWyctdScsIHRoaXMudWRpZF0sIHtlbnY6IHNwYXduRW52fSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIud2FybignQ291bGQgbm90IGNhcHR1cmUgZGV2aWNlIGxvZyB1c2luZyBsaWJpbW9iaWxlZGV2aWNlIGlkZXZpY2VzeXNsb2cuICcgK1xuICAgICAgICAgICAgICAgICAgJ0xpYmltb2JpbGVkZXZpY2UgaXMgcHJvYmFibHkgbm90IGluc3RhbGxlZCcpO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdBdHRlbXB0aW5nIGlPUyBkZXZpY2UgbG9nIGNhcHR1cmUgdmlhIGRldmljZWNvbnNvbGUnKTtcbiAgICAgIHNwYXduRW52LlBBVEggPSBgJHtwcm9jZXNzLmVudi5QQVRIfToke0RFVklDRV9DT05TT0xFX1BBVEh9YDtcbiAgICAgIHNwYXduRW52LkRZTERfTElCUkFSWV9QQVRIID0gYCR7REVWSUNFX0NPTlNPTEVfUEFUSH06JHtwcm9jZXNzLmVudi5EWUxEX0xJQlJBUllfUEFUSH1gO1xuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3MoJ2RldmljZWNvbnNvbGUnLCBbJy11JywgdGhpcy51ZGlkXSwge2Vudjogc3Bhd25FbnZ9KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZSAoKSB7XG4gICAgaWYgKHRoaXMudWRpZCkgeyAvLyBpZiB3ZSBoYXZlIGEgcmVhbCBkZXZpY2VcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0Q2FwdHVyZVJlYWxEZXZpY2UoKTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCBpZiB3ZSBoYXZlIGEgc2ltdWxhdG9yLi4uXG4gICAgbGV0IHhDb2RlVmVyc2lvbiA9IGF3YWl0IHhjb2RlLmdldFZlcnNpb24odHJ1ZSk7XG5cbiAgICBsb2dnZXIuZGVidWcoYFN0YXJ0aW5nIGlPUyAke2F3YWl0IHRoaXMuc2ltLmdldFBsYXRmb3JtVmVyc2lvbigpfSBzaW11bGF0b3IgbG9nIGNhcHR1cmVgKTtcbiAgICBpZiAoeENvZGVWZXJzaW9uLm1ham9yIDwgNSkge1xuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3MoJ3RhaWwnLCBbJy1mJywgJy1uJywgJzEnLCBTWVNURU1fTE9HX1BBVEhdKTtcbiAgICAgIGF3YWl0IHRoaXMuZmluaXNoU3RhcnRpbmdMb2dDYXB0dXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyB4Y29kZSA2K1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMuc2ltLnVkaWQpKSB7XG4gICAgICBsb2dnZXIuZXJyb3JBbmRUaHJvdyhgaU9TICR7eENvZGVWZXJzaW9uLnZlcnNpb25TdHJpbmd9IGxvZyBjYXB0dXJlIHJlcXVpcmVzIGEgc2ltIHVkaWRgKTtcbiAgICB9XG5cbiAgICBsZXQgbG9nUGF0aCA9IHRoaXMuc2ltLmdldExvZ0RpcigpO1xuICAgIHRyeSB7XG4gICAgICBpZiAobG9nUGF0aC5pbmRleE9mKCcqJykgPj0gMCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYExvZyBwYXRoIGhhcyAqIGluIGl0LiBVbmFibGUgdG8gc3RhcnQgbG9nIGNhcHR1cmU6ICR7bG9nUGF0aH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN5c3RlbUxvZ1BhdGggPSBwYXRoLnJlc29sdmUobG9nUGF0aCwgJ3N5c3RlbS5sb2cnKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgU3lzdGVtIGxvZyBwYXRoOiAke3N5c3RlbUxvZ1BhdGh9YCk7XG4gICAgICBhd2FpdCBta2RpcnAobG9nUGF0aCk7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUoc3lzdGVtTG9nUGF0aCwgJ0EgbmV3IEFwcGl1bSBzZXNzaW9uIGlzIGFib3V0IHRvIHN0YXJ0IVxcbicsIHtmbGFnOiAnYSd9KTtcbiAgICAgIGxldCBmaWxlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVzID0gYXdhaXQgZnMuZ2xvYihzeXN0ZW1Mb2dQYXRoKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzdGFydCBsb2cgY2FwdHVyZScpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgQ291bGQgbm90IHN0YXJ0IGxvZyBjYXB0dXJlIGJlY2F1c2Ugbm8gaU9TIGAgK1xuICAgICAgICAgICAgICAgICAgICAgYHNpbXVsYXRvciBsb2dzIGNvdWxkIGJlIGZvdW5kIGF0ICR7c3lzdGVtTG9nUGF0aH0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgYExvZ2dpbmcgd2lsbCBub3QgYmUgZnVuY3Rpb25hbCBmb3IgdGhpcyBydW5gKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGxhc3RNb2RpZmllZExvZ1BhdGggPSBmaWxlc1swXTtcbiAgICAgIGxldCBsYXN0TW9kaWZpZWRMb2dUaW1lID0gYXdhaXQgZnMuc3RhdChsYXN0TW9kaWZpZWRMb2dQYXRoKS5tdGltZTtcbiAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgbGV0IG10aW1lID0gYXdhaXQgZnMuc3RhdChmaWxlKS5tdGltZTtcbiAgICAgICAgaWYgKG10aW1lID4gbGFzdE1vZGlmaWVkTG9nVGltZSkge1xuICAgICAgICAgIGxhc3RNb2RpZmllZExvZ1BhdGggPSBmaWxlO1xuICAgICAgICAgIGxhc3RNb2RpZmllZExvZ1RpbWUgPSBtdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3MoJ3RhaWwnLCBbJy1mJywgJy1uJywgJzEnLCBsYXN0TW9kaWZpZWRMb2dQYXRoXSk7XG4gICAgICBhd2FpdCB0aGlzLmZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coYFN5c3RlbSBsb2cgY2FwdHVyZSBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmluaXNoU3RhcnRpbmdMb2dDYXB0dXJlICgpIHtcbiAgICBpZiAoIXRoaXMucHJvYykge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coJ0NvdWxkIG5vdCBjYXB0dXJlIGRldmljZSBsb2cnKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0TGluZSA9IHRydWU7XG4gICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgaWYgKGZpcnN0TGluZSkge1xuICAgICAgICAgIGlmIChzdGRvdXQuc3Vic3RyKC0xLCAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHN0b3JlIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBsb2cgYmVjYXVzZSBpdCBjYW1lIGJlZm9yZSB0aGUgc2ltIG9yIGRldmljZSB3YXMgbGF1bmNoZWRcbiAgICAgICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ1JvdyArPSBzdGRvdXQ7XG4gICAgICAgICAgaWYgKHN0ZG91dC5zdWJzdHIoLTEsIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5sb2dSb3cgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgdGhpcy5vbk91dHB1dCgnU1RERVJSJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgc2QgPSAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmICgvZXhlY3ZwXFwoXFwpLy50ZXN0KHN0ZGVycikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpT1MgbG9nIGNhcHR1cmUgcHJvY2VzcyBmYWlsZWQgdG8gc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGRvdXQgfHwgc3RkZXJyO1xuICAgIH07XG4gICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KHNkLCBTVEFSVF9USU1FT1VUKTtcbiAgfVxuXG4gIGFzeW5jIHN0b3BDYXB0dXJlICgpIHtcbiAgICBsb2dnZXIuZGVidWcoJ1N0b3BwaW5nIGlPUyBsb2cgY2FwdHVyZScpO1xuICAgIGlmICh0aGlzLnByb2MgJiYgdGhpcy5wcm9jLmlzUnVubmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR1RFUk0nLCAxMDAwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3Qgc3RvcCBsb2cgY2FwdHVyZSBwcm9jZXNzLiBTZW5kaW5nIFNJR0tJTEwuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR0tJTEwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgfVxuXG4gIF9vYmplY3RTaXplIChvYmopIHtcbiAgICBsZXQgb2JqZWN0TGlzdCA9IFtdO1xuICAgIGxldCBzdGFjayA9IFtvYmpdO1xuICAgIGxldCBieXRlcyA9IDA7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICBsZXQgdmFsdWUgPSBzdGFjay5wb3AoKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICBieXRlcyArPSA0O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ5dGVzICs9IHZhbHVlLmxlbmd0aCAqIDI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnl0ZXMgKz0gODtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBvYmplY3RMaXN0LmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICBvYmplY3RMaXN0LnB1c2godmFsdWUpO1xuICAgICAgICBmb3IgKGxldCBpIGluIHZhbHVlKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgX2FwcGVuZExvZyAobG9nT2JqKSB7XG4gICAgY29uc3QgaGVhcFN0YXRzID0gdjguZ2V0SGVhcFN0YXRpc3RpY3MoKTtcbiAgICBjb25zdCBoZWFwQXZhaWxTaXplID0gaGVhcFN0YXRzLmhlYXBfc2l6ZV9saW1pdCAtIGhlYXBTdGF0cy51c2VkX2hlYXBfc2l6ZTtcbiAgICBjb25zdCBsb2dPYmpTaXplID0gdGhpcy5fb2JqZWN0U2l6ZShsb2dPYmopO1xuICAgIGlmIChsb2dPYmpTaXplICsgdGhpcy5sb2dzU2l6ZSA+PSBoZWFwQXZhaWxTaXplIC8gNCkge1xuICAgICAgLy8gU2hyaW5rIGxvZyByZWNvcmRzIGNhY2hlIGJ5IDI1JSBpZiBpdHMgdG90YWwgc2l6ZSBpcyBncmVhdGVyIHRoYW4gMjUlIG9mIHNwYWNlXG4gICAgICAvLyBwb3RlbnRpYWxseSBhdmFpbGFibGUgZm9yIGFsbG9jYXRpb24gYnkgTm9kZUpTIGhlYXBcbiAgICAgIGxvZ2dlci53YXJuKCdTaHJpbmtpbmcgY3VycmVudCBkZXZpY2UgbG9ncyBjYWNoZSB0byBhdm9pZCBoZWFwIG92ZXJmbG93Jyk7XG4gICAgICBjb25zdCBzaHJpbmtUb0lkeCA9IHRoaXMubG9ncy5sZW5ndGggLyA0O1xuICAgICAgY29uc3Qgc2hyaW5rU2l6ZSA9IHRoaXMuX29iamVjdFNpemUodGhpcy5sb2dzLnNsaWNlKDAsIHNocmlua1RvSWR4KSk7XG4gICAgICB0aGlzLmxvZ3MgPSB0aGlzLmxvZ3Muc2xpY2Uoc2hyaW5rVG9JZHgpO1xuICAgICAgdGhpcy5sb2dzU2l6ZSAtPSBzaHJpbmtTaXplO1xuICAgICAgaWYgKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA+PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPj0gc2hyaW5rVG9JZHgpIHtcbiAgICAgICAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgLT0gc2hyaW5rVG9JZHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ3MucHVzaChsb2dPYmopO1xuICAgIHRoaXMubG9nc1NpemUgKz0gbG9nT2JqU2l6ZTtcbiAgfVxuXG4gIG9uT3V0cHV0IChwcmVmaXggPSAnJykge1xuICAgIHRoaXMubG9nc1N0YXJ0ZWQoKTtcblxuICAgIGxldCBsb2dzID0gdGhpcy5sb2dSb3cuc3BsaXQoJ1xcbicpO1xuICAgIGZvciAobGV0IGxvZyBvZiBsb2dzKSB7XG4gICAgICBpZiAobG9nKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dnaW5nTW9kZU9uKSB7XG4gICAgICAgICAgLy8gZmlndXJlIG91dCBpZiB0aGlzIGxvZyByb3cgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBvdXIgbG9nIGNhcHR1cmUgb3Igbm90XG4gICAgICAgICAgbGV0IGxvZ1Jvd1BhcnRzID0gbG9nLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgbGV0IGxvZ1Jvd0RhdGUgPSBuZXcgRGF0ZShgJHt0aGlzLmlvc0xvZ1N0YXJ0VGltZS5nZXRGdWxsWWVhcigpfSAke2xvZ1Jvd1BhcnRzWzBdfSAke2xvZ1Jvd1BhcnRzWzFdfSAke2xvZ1Jvd1BhcnRzWzJdfWApO1xuICAgICAgICAgIGlmIChsb2dSb3dEYXRlLmlzQWZ0ZXIodGhpcy5pb3NMb2dTdGFydFRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dpbmdNb2RlT24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2dnaW5nTW9kZU9uKSB7XG4gICAgICAgICAgbGV0IGxvZ09iaiA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGxldmVsOiAnQUxMJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGxvZ1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fYXBwZW5kTG9nKGxvZ09iaik7XG4gICAgICAgICAgaWYgKHRoaXMuc2hvd0xvZ3MpIHtcbiAgICAgICAgICAgIGxldCBzcGFjZSA9IHByZWZpeC5sZW5ndGggPiAwID8gJyAnIDogJyc7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW0lPU19TWVNMT0dfUk9XJHtzcGFjZX0ke3ByZWZpeH1dICR7bG9nfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldExvZ3MgKCkge1xuICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID4gMCAmJiB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLmxvZ3MubGVuZ3RoKSB7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgaWYgKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5sb2dzLnNsaWNlKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmxvZ3M7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPSB0aGlzLmxvZ3MubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsTG9ncyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9ncztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJT1NMb2c7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=

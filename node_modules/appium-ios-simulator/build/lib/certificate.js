'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _appiumSupport = require('appium-support');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

// these will be lazily loaded, because the sqlite3 module installation is
// fragile and often doesn't load. we don't want the error message unless
// the user actually tries to use the certificate functionality
var sqlite3 = undefined;
var openssl = undefined;

function loadSqlite3() {
  try {
    sqlite3 = _bluebird2['default'].promisifyAll(require('sqlite3'));
    openssl = _bluebird2['default'].promisify(require('openssl-wrapper').exec);
  } catch (err) {
    _logger2['default'].errorAndThrow('Unable to load sqlite3 module: ' + err.message + '.');
  }
}

var tset = '<?xml version="1.0" encoding="UTF-8"?>\n\n    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n    <plist version="1.0">\n    <array/>\n</plist>';

/**
 * Library for programatically adding certificates
 */

var Certificate = (function () {
  function Certificate(pemFilename) {
    _classCallCheck(this, Certificate);

    this.pemFilename = pemFilename;

    // there is no point in going further in the process if we can't access the
    // necessary sqlite3 module
    loadSqlite3();
  }

  /**
   * Interface for adding and removing records to TrustStore.sqlite3 databases that Keychains use
   */

  /**
   * Add a certificate to the TrustStore
   */

  _createClass(Certificate, [{
    key: 'add',
    value: function add(dir) {
      var data, subject, fingerprint, trustStore;
      return _regeneratorRuntime.async(function add$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getDerData(this.pemFilename));

          case 2:
            data = context$2$0.sent;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.getSubject(this.pemFilename));

          case 5:
            subject = context$2$0.sent;
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(this.getFingerPrint(this.data));

          case 8:
            fingerprint = context$2$0.sent;
            trustStore = new TrustStore(dir);
            return context$2$0.abrupt('return', trustStore.addRecord(fingerprint, tset, subject, data));

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Checks if keychain at given directory has this certificate
     */
  }, {
    key: 'has',
    value: function has(dir) {
      var subject, trustStore, records;
      return _regeneratorRuntime.async(function has$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getSubject(this.pemFilename));

          case 2:
            subject = context$2$0.sent;
            trustStore = new TrustStore(dir);
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(trustStore.getRecords(subject));

          case 6:
            records = context$2$0.sent;
            return context$2$0.abrupt('return', records.length > 0);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Remove certificate from the TrustStore
     */
  }, {
    key: 'remove',
    value: function remove(dir) {
      var subject, trustStore;
      return _regeneratorRuntime.async(function remove$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getSubject(this.pemFilename));

          case 2:
            subject = context$2$0.sent;
            trustStore = new TrustStore(dir);
            return context$2$0.abrupt('return', trustStore.removeRecord(subject));

          case 5:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Translate PEM file to DER buffer
     */
  }, {
    key: 'getDerData',
    value: function getDerData() {
      return _regeneratorRuntime.async(function getDerData$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.data) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', this.data);

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(openssl('x509', {
              outform: 'der',
              'in': this.pemFilename
            }));

          case 4:
            this.data = context$2$0.sent;
            return context$2$0.abrupt('return', this.data);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get SHA1 fingerprint from der data before
     */
  }, {
    key: 'getFingerPrint',
    value: function getFingerPrint() {
      var data, shasum;
      return _regeneratorRuntime.async(function getFingerPrint$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.fingerprint) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', this.fingerprint);

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.getDerData());

          case 4:
            data = context$2$0.sent;
            shasum = _crypto2['default'].createHash('sha1');

            shasum.update(data);
            this.fingerprint = shasum.digest();
            return context$2$0.abrupt('return', this.fingerprint);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Parse the subject from the der data
     */
  }, {
    key: 'getSubject',
    value: function getSubject() {
      var subject, subRegex;
      return _regeneratorRuntime.async(function getSubject$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.subject) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', this.subject);

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(openssl('x509', {
              noout: true,
              subject: true,
              'in': this.pemFilename
            }));

          case 4:
            subject = context$2$0.sent;
            subRegex = /^subject[\w\W]*\/CN=([\w\W]*)(\n)?/;

            this.subject = subject.toString().match(subRegex)[1];
            return context$2$0.abrupt('return', this.subject);

          case 8:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return Certificate;
})();

var TrustStore = (function () {
  function TrustStore(sharedResourceDir) {
    _classCallCheck(this, TrustStore);

    this.sharedResourceDir = sharedResourceDir;

    // there is no point in going further in the process if we can't access the
    // necessary sqlite3 module
    loadSqlite3();
  }

  /**
   * Get TrustStore database associated with this simulator
   */

  _createClass(TrustStore, [{
    key: 'getDB',
    value: function getDB() {
      var keychainsPath;
      return _regeneratorRuntime.async(function getDB$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.db) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', this.db);

          case 2:
            keychainsPath = _path2['default'].resolve(this.sharedResourceDir, 'Library', 'Keychains');
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(keychainsPath));

          case 5:
            if (context$2$0.sent) {
              context$2$0.next = 8;
              break;
            }

            context$2$0.next = 8;
            return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(keychainsPath));

          case 8:

            // Open sqlite database
            this.db = new sqlite3.Database(_path2['default'].resolve(keychainsPath, 'TrustStore.sqlite3'));

            // If it doesn't have a tsettings table, create one
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.db.runAsync('\n      CREATE TABLE IF NOT EXISTS tsettings (\n        sha1 BLOB NOT NULL DEFAULT \'\',\n        subj BLOB NOT NULL DEFAULT \'\',\n        tset BLOB,\n        data\n        BLOB,\n        PRIMARY KEY(sha1)\n      );\n      CREATE INDEX isubj ON tsettings(subj);\n    '));

          case 11:
            return context$2$0.abrupt('return', this.db);

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Add record to tsettings
     */
  }, {
    key: 'addRecord',
    value: function addRecord(sha1, tset, subj, data) {
      var existingRecords, db;
      return _regeneratorRuntime.async(function addRecord$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getRecords(subj));

          case 2:
            existingRecords = context$2$0.sent;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.getDB());

          case 5:
            db = context$2$0.sent;

            if (!(existingRecords.length > 0)) {
              context$2$0.next = 12;
              break;
            }

            context$2$0.next = 9;
            return _regeneratorRuntime.awrap(db.runAsync('UPDATE tsettings SET sha1=?, tset=?, data=? WHERE subj=?', [sha1, tset, data, subj]));

          case 9:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 12:
            context$2$0.next = 14;
            return _regeneratorRuntime.awrap(db.runAsync('INSERT INTO tsettings (sha1, subj, tset, data) VALUES (?, ?, ?, ?)', [sha1, subj, tset, data]));

          case 14:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 15:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Remove record from tsettings
     */
  }, {
    key: 'removeRecord',
    value: function removeRecord(subj) {
      var db;
      return _regeneratorRuntime.async(function removeRecord$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getDB());

          case 2:
            db = context$2$0.sent;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(db.runAsync('DELETE FROM tsettings WHERE subj = ?', [subj]));

          case 5:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get a record from tsettings
     */
  }, {
    key: 'getRecords',
    value: function getRecords(subj) {
      var db;
      return _regeneratorRuntime.async(function getRecords$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.getDB());

          case 2:
            db = context$2$0.sent;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(db.allAsync('SELECT * FROM tsettings WHERE subj = ?', [subj]));

          case 5:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return TrustStore;
})();

exports['default'] = Certificate;
exports.Certificate = Certificate;
exports.TrustStore = TrustStore;

// Convert 'pem' file to 'der'

// Convert 'pem' file to 'der'

// If the sim doesn't have a keychains directory, create one
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jZXJ0aWZpY2F0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztzQkFBbUIsUUFBUTs7Ozt3QkFDYixVQUFVOzs7O29CQUNQLE1BQU07Ozs7NkJBQ0ksZ0JBQWdCOztzQkFDM0IsVUFBVTs7Ozs7OztBQU0xQixJQUFJLE9BQU8sWUFBQSxDQUFDO0FBQ1osSUFBSSxPQUFPLFlBQUEsQ0FBQzs7QUFFWixTQUFTLFdBQVcsR0FBSTtBQUN0QixNQUFJO0FBQ0YsV0FBTyxHQUFHLHNCQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUM3QyxXQUFPLEdBQUcsc0JBQUUsU0FBUyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQ3hELENBQUMsT0FBTyxHQUFHLEVBQUU7QUFDWix3QkFBSSxhQUFhLHFDQUFtQyxHQUFHLENBQUMsT0FBTyxPQUFJLENBQUM7R0FDckU7Q0FDRjs7QUFFRCxJQUFNLElBQUksNE1BSUQsQ0FBQzs7Ozs7O0lBS0osV0FBVztBQUVILFdBRlIsV0FBVyxDQUVGLFdBQVcsRUFBRTswQkFGdEIsV0FBVzs7QUFHYixRQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzs7OztBQUkvQixlQUFXLEVBQUUsQ0FBQztHQUNmOzs7Ozs7Ozs7O2VBUkcsV0FBVzs7V0FhTCxhQUFDLEdBQUc7VUFDUixJQUFJLEVBQ0osT0FBTyxFQUNQLFdBQVcsRUFFWCxVQUFVOzs7Ozs2Q0FKRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7OztBQUE5QyxnQkFBSTs7NkNBQ1ksSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7QUFBakQsbUJBQU87OzZDQUNhLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzs7O0FBQWxELHVCQUFXO0FBRVgsc0JBQVUsR0FBRyxJQUFJLFVBQVUsQ0FB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b3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGZzLCBta2RpcnAgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcblxuXG4vLyB0aGVzZSB3aWxsIGJlIGxhemlseSBsb2FkZWQsIGJlY2F1c2UgdGhlIHNxbGl0ZTMgbW9kdWxlIGluc3RhbGxhdGlvbiBpc1xuLy8gZnJhZ2lsZSBhbmQgb2Z0ZW4gZG9lc24ndCBsb2FkLiB3ZSBkb24ndCB3YW50IHRoZSBlcnJvciBtZXNzYWdlIHVubGVzc1xuLy8gdGhlIHVzZXIgYWN0dWFsbHkgdHJpZXMgdG8gdXNlIHRoZSBjZXJ0aWZpY2F0ZSBmdW5jdGlvbmFsaXR5XG5sZXQgc3FsaXRlMztcbmxldCBvcGVuc3NsO1xuXG5mdW5jdGlvbiBsb2FkU3FsaXRlMyAoKSB7XG4gIHRyeSB7XG4gICAgc3FsaXRlMyA9IEIucHJvbWlzaWZ5QWxsKHJlcXVpcmUoJ3NxbGl0ZTMnKSk7XG4gICAgb3BlbnNzbCA9IEIucHJvbWlzaWZ5KHJlcXVpcmUoJ29wZW5zc2wtd3JhcHBlcicpLmV4ZWMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVW5hYmxlIHRvIGxvYWQgc3FsaXRlMyBtb2R1bGU6ICR7ZXJyLm1lc3NhZ2V9LmApO1xuICB9XG59XG5cbmNvbnN0IHRzZXQgPSBgPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiPz5cXG5cbiAgICA8IURPQ1RZUEUgcGxpc3QgUFVCTElDIFxcXCItLy9BcHBsZS8vRFREIFBMSVNUIDEuMC8vRU5cXFwiIFxcXCJodHRwOi8vd3d3LmFwcGxlLmNvbS9EVERzL1Byb3BlcnR5TGlzdC0xLjAuZHRkXFxcIj5cbiAgICA8cGxpc3QgdmVyc2lvbj1cXFwiMS4wXFxcIj5cbiAgICA8YXJyYXkvPlxuPC9wbGlzdD5gO1xuXG4vKipcbiAqIExpYnJhcnkgZm9yIHByb2dyYW1hdGljYWxseSBhZGRpbmcgY2VydGlmaWNhdGVzXG4gKi9cbmNsYXNzIENlcnRpZmljYXRlIHtcblxuICBjb25zdHJ1Y3RvciAocGVtRmlsZW5hbWUpIHtcbiAgICB0aGlzLnBlbUZpbGVuYW1lID0gcGVtRmlsZW5hbWU7XG5cbiAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBpbiBnb2luZyBmdXJ0aGVyIGluIHRoZSBwcm9jZXNzIGlmIHdlIGNhbid0IGFjY2VzcyB0aGVcbiAgICAvLyBuZWNlc3Nhcnkgc3FsaXRlMyBtb2R1bGVcbiAgICBsb2FkU3FsaXRlMygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNlcnRpZmljYXRlIHRvIHRoZSBUcnVzdFN0b3JlXG4gICAqL1xuICBhc3luYyBhZGQgKGRpcikge1xuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5nZXREZXJEYXRhKHRoaXMucGVtRmlsZW5hbWUpO1xuICAgIGxldCBzdWJqZWN0ID0gYXdhaXQgdGhpcy5nZXRTdWJqZWN0KHRoaXMucGVtRmlsZW5hbWUpO1xuICAgIGxldCBmaW5nZXJwcmludCA9IGF3YWl0IHRoaXMuZ2V0RmluZ2VyUHJpbnQodGhpcy5kYXRhKTtcblxuICAgIGxldCB0cnVzdFN0b3JlID0gbmV3IFRydXN0U3RvcmUoZGlyKTtcbiAgICByZXR1cm4gdHJ1c3RTdG9yZS5hZGRSZWNvcmQoZmluZ2VycHJpbnQsIHRzZXQsIHN1YmplY3QsIGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBrZXljaGFpbiBhdCBnaXZlbiBkaXJlY3RvcnkgaGFzIHRoaXMgY2VydGlmaWNhdGVcbiAgICovXG4gIGFzeW5jIGhhcyAoZGlyKSB7XG4gICAgbGV0IHN1YmplY3QgPSBhd2FpdCB0aGlzLmdldFN1YmplY3QodGhpcy5wZW1GaWxlbmFtZSk7XG5cbiAgICBsZXQgdHJ1c3RTdG9yZSA9IG5ldyBUcnVzdFN0b3JlKGRpcik7XG4gICAgbGV0IHJlY29yZHMgPSBhd2FpdCB0cnVzdFN0b3JlLmdldFJlY29yZHMoc3ViamVjdCk7XG4gICAgcmV0dXJuIHJlY29yZHMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY2VydGlmaWNhdGUgZnJvbSB0aGUgVHJ1c3RTdG9yZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlIChkaXIpIHtcbiAgICBsZXQgc3ViamVjdCA9IGF3YWl0IHRoaXMuZ2V0U3ViamVjdCh0aGlzLnBlbUZpbGVuYW1lKTtcbiAgICBsZXQgdHJ1c3RTdG9yZSA9IG5ldyBUcnVzdFN0b3JlKGRpcik7XG4gICAgcmV0dXJuIHRydXN0U3RvcmUucmVtb3ZlUmVjb3JkKHN1YmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBQRU0gZmlsZSB0byBERVIgYnVmZmVyXG4gICAqL1xuICBhc3luYyBnZXREZXJEYXRhICgpIHtcbiAgICBpZiAodGhpcy5kYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgJ3BlbScgZmlsZSB0byAnZGVyJ1xuICAgIHRoaXMuZGF0YSA9IGF3YWl0IG9wZW5zc2woJ3g1MDknLCB7XG4gICAgICBvdXRmb3JtOiAnZGVyJyxcbiAgICAgIGluOiB0aGlzLnBlbUZpbGVuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBTSEExIGZpbmdlcnByaW50IGZyb20gZGVyIGRhdGEgYmVmb3JlXG4gICAqL1xuICBhc3luYyBnZXRGaW5nZXJQcmludCAoKSB7XG4gICAgaWYgKHRoaXMuZmluZ2VycHJpbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmdlcnByaW50O1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5nZXREZXJEYXRhKCk7XG4gICAgbGV0IHNoYXN1bSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgc2hhc3VtLnVwZGF0ZShkYXRhKTtcbiAgICB0aGlzLmZpbmdlcnByaW50ID0gc2hhc3VtLmRpZ2VzdCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmdlcnByaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBzdWJqZWN0IGZyb20gdGhlIGRlciBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTdWJqZWN0ICgpIHtcbiAgICBpZiAodGhpcy5zdWJqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWJqZWN0O1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgJ3BlbScgZmlsZSB0byAnZGVyJ1xuICAgIGxldCBzdWJqZWN0ID0gYXdhaXQgb3BlbnNzbCgneDUwOScsIHtcbiAgICAgIG5vb3V0OiB0cnVlLFxuICAgICAgc3ViamVjdDogdHJ1ZSxcbiAgICAgIGluOiB0aGlzLnBlbUZpbGVuYW1lXG4gICAgfSk7XG4gICAgbGV0IHN1YlJlZ2V4ID0gL15zdWJqZWN0W1xcd1xcV10qXFwvQ049KFtcXHdcXFddKikoXFxuKT8vO1xuICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3QudG9TdHJpbmcoKS5tYXRjaChzdWJSZWdleClbMV07XG4gICAgcmV0dXJuIHRoaXMuc3ViamVjdDtcbiAgfVxuXG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIHJlY29yZHMgdG8gVHJ1c3RTdG9yZS5zcWxpdGUzIGRhdGFiYXNlcyB0aGF0IEtleWNoYWlucyB1c2VcbiAqL1xuY2xhc3MgVHJ1c3RTdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChzaGFyZWRSZXNvdXJjZURpcikge1xuICAgIHRoaXMuc2hhcmVkUmVzb3VyY2VEaXIgPSBzaGFyZWRSZXNvdXJjZURpcjtcblxuICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGluIGdvaW5nIGZ1cnRoZXIgaW4gdGhlIHByb2Nlc3MgaWYgd2UgY2FuJ3QgYWNjZXNzIHRoZVxuICAgIC8vIG5lY2Vzc2FyeSBzcWxpdGUzIG1vZHVsZVxuICAgIGxvYWRTcWxpdGUzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFRydXN0U3RvcmUgZGF0YWJhc2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2ltdWxhdG9yXG4gICAqL1xuICBhc3luYyBnZXREQiAoKSB7XG4gICAgaWYgKHRoaXMuZGIpIHtcbiAgICAgIHJldHVybiB0aGlzLmRiO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzaW0gZG9lc24ndCBoYXZlIGEga2V5Y2hhaW5zIGRpcmVjdG9yeSwgY3JlYXRlIG9uZVxuICAgIGxldCBrZXljaGFpbnNQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMuc2hhcmVkUmVzb3VyY2VEaXIsICdMaWJyYXJ5JywgJ0tleWNoYWlucycpO1xuICAgIGlmICghKGF3YWl0IGZzLmV4aXN0cyhrZXljaGFpbnNQYXRoKSkpIHtcbiAgICAgIGF3YWl0IG1rZGlycChrZXljaGFpbnNQYXRoKTtcbiAgICB9XG5cbiAgICAvLyBPcGVuIHNxbGl0ZSBkYXRhYmFzZVxuICAgIHRoaXMuZGIgPSBuZXcgc3FsaXRlMy5EYXRhYmFzZShwYXRoLnJlc29sdmUoa2V5Y2hhaW5zUGF0aCwgJ1RydXN0U3RvcmUuc3FsaXRlMycpKTtcblxuICAgIC8vIElmIGl0IGRvZXNuJ3QgaGF2ZSBhIHRzZXR0aW5ncyB0YWJsZSwgY3JlYXRlIG9uZVxuICAgIGF3YWl0IHRoaXMuZGIucnVuQXN5bmMoYFxuICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgdHNldHRpbmdzIChcbiAgICAgICAgc2hhMSBCTE9CIE5PVCBOVUxMIERFRkFVTFQgJycsXG4gICAgICAgIHN1YmogQkxPQiBOT1QgTlVMTCBERUZBVUxUICcnLFxuICAgICAgICB0c2V0IEJMT0IsXG4gICAgICAgIGRhdGFcbiAgICAgICAgQkxPQixcbiAgICAgICAgUFJJTUFSWSBLRVkoc2hhMSlcbiAgICAgICk7XG4gICAgICBDUkVBVEUgSU5ERVggaXN1YmogT04gdHNldHRpbmdzKHN1YmopO1xuICAgIGApO1xuXG4gICAgcmV0dXJuIHRoaXMuZGI7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHJlY29yZCB0byB0c2V0dGluZ3NcbiAgICovXG4gIGFzeW5jIGFkZFJlY29yZCAoc2hhMSwgdHNldCwgc3ViaiwgZGF0YSkge1xuICAgIGxldCBleGlzdGluZ1JlY29yZHMgPSBhd2FpdCB0aGlzLmdldFJlY29yZHMoc3Viaik7XG4gICAgbGV0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgIGlmIChleGlzdGluZ1JlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGF3YWl0IGRiLnJ1bkFzeW5jKGBVUERBVEUgdHNldHRpbmdzIFNFVCBzaGExPT8sIHRzZXQ9PywgZGF0YT0/IFdIRVJFIHN1Ymo9P2AsIFtzaGExLCB0c2V0LCBkYXRhLCBzdWJqXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCBkYi5ydW5Bc3luYyhgSU5TRVJUIElOVE8gdHNldHRpbmdzIChzaGExLCBzdWJqLCB0c2V0LCBkYXRhKSBWQUxVRVMgKD8sID8sID8sID8pYCwgW3NoYTEsIHN1YmosIHRzZXQsIGRhdGFdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHJlY29yZCBmcm9tIHRzZXR0aW5nc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUmVjb3JkIChzdWJqKSB7XG4gICAgbGV0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgIHJldHVybiBhd2FpdCBkYi5ydW5Bc3luYyhgREVMRVRFIEZST00gdHNldHRpbmdzIFdIRVJFIHN1YmogPSA/YCwgW3N1YmpdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWNvcmQgZnJvbSB0c2V0dGluZ3NcbiAgICovXG4gIGFzeW5jIGdldFJlY29yZHMgKHN1YmopIHtcbiAgICBsZXQgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgcmV0dXJuIGF3YWl0IGRiLmFsbEFzeW5jKGBTRUxFQ1QgKiBGUk9NIHRzZXR0aW5ncyBXSEVSRSBzdWJqID0gP2AsIFtzdWJqXSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2VydGlmaWNhdGU7XG5leHBvcnQgeyBDZXJ0aWZpY2F0ZSwgVHJ1c3RTdG9yZSB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9

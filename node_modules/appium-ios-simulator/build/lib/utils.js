'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _appiumXcode = require('appium-xcode');

var _nodeSimctl = require('node-simctl');

var _appiumSupport = require('appium-support');

var _certificate = require('./certificate');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _simulatorXcode6 = require('./simulator-xcode-6');

var _simulatorXcode62 = _interopRequireDefault(_simulatorXcode6);

var OSASCRIPT_TIMEOUT = 10000;

function killAllSimulators() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? OSASCRIPT_TIMEOUT : arguments[0];

  var appName, xcodeVersion, errString, remainingDevices, allSimsAreDown, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, device;

  return _regeneratorRuntime.async(function killAllSimulators$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        allSimsAreDown = function allSimsAreDown() {
          var devices;
          return _regeneratorRuntime.async(function allSimsAreDown$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                remainingDevices = [];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

              case 3:
                devices = context$2$0.sent;

                devices = _lodash2['default'].flatten(_lodash2['default'].values(devices));
                return context$2$0.abrupt('return', _lodash2['default'].every(devices, function (sim) {
                  var state = sim.state.toLowerCase();
                  var done = state === 'shutdown' || state === 'unavailable' || state === 'disconnected';
                  if (!done) {
                    remainingDevices.push('Simulator not shut down: ' + sim.name + ' (' + sim.sdk + ', udid: ' + (sim.udid + ') is still in state \'' + state + '\''));
                  }
                  return done;
                }));

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, this);
        };

        _logger2['default'].debug('Killing all iOS Simulators');

        appName = undefined;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _appiumXcode.getVersion)(true));

      case 5:
        xcodeVersion = context$1$0.sent;

        if (xcodeVersion.major >= 7) {
          appName = 'Simulator';
        } else {
          appName = 'iOS Simulator';
        }

        context$1$0.prev = 7;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', ['-e', 'quit app "' + appName + '"'], { timeout: timeout }));

      case 10:
        context$1$0.next = 26;
        break;

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](7);
        errString = JSON.stringify(context$1$0.t0);

        if (!errString.match(/Application isn.t running/)) {
          context$1$0.next = 19;
          break;
        }

        // on some systems we get an error that the application is not running
        _logger2['default'].debug('Application is not running. Continuing');
        context$1$0.next = 26;
        break;

      case 19:
        if (!context$1$0.t0.message.match(/timed out/)) {
          context$1$0.next = 25;
          break;
        }

        // sometimes, especially in xcode 8, the sim hangs
        _logger2['default'].debug('Killing simulator timed out. Using killall signal');
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('killall', [appName]));

      case 23:
        context$1$0.next = 26;
        break;

      case 25:
        _logger2['default'].errorAndThrow(context$1$0.t0);

      case 26:
        remainingDevices = undefined;
        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(allSimsAreDown, {
          waitMs: 60 * 1000,
          intervalMs: 200
        }));

      case 30:
        context$1$0.next = 56;
        break;

      case 32:
        context$1$0.prev = 32;
        context$1$0.t1 = context$1$0['catch'](27);

        if (!(remainingDevices && remainingDevices.length !== 0)) {
          context$1$0.next = 55;
          break;
        }

        _logger2['default'].error('The following devices are not in the correct state:');
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 39;
        for (_iterator = _getIterator(remainingDevices); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          device = _step.value;

          _logger2['default'].error('    ' + device);
        }
        context$1$0.next = 47;
        break;

      case 43:
        context$1$0.prev = 43;
        context$1$0.t2 = context$1$0['catch'](39);
        _didIteratorError = true;
        _iteratorError = context$1$0.t2;

      case 47:
        context$1$0.prev = 47;
        context$1$0.prev = 48;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 50:
        context$1$0.prev = 50;

        if (!_didIteratorError) {
          context$1$0.next = 53;
          break;
        }

        throw _iteratorError;

      case 53:
        return context$1$0.finish(50);

      case 54:
        return context$1$0.finish(47);

      case 55:
        throw context$1$0.t1;

      case 56:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 12], [27, 32], [39, 43, 47, 55], [48,, 50, 54]]);
}

function endAllSimulatorDaemons() {
  var _arr, _i, servicePattern, launchCtlCommand, stopCmd, removeCmd;

  return _regeneratorRuntime.async(function endAllSimulatorDaemons$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Ending all simulator daemons');
        _arr = ['com.apple.iphonesimulator', 'com.apple.CoreSimulator'];
        _i = 0;

      case 3:
        if (!(_i < _arr.length)) {
          context$1$0.next = 28;
          break;
        }

        servicePattern = _arr[_i];

        _logger2['default'].debug('Killing any other ' + servicePattern + ' daemons');
        launchCtlCommand = 'launchctl list | grep ' + servicePattern + ' | cut -f 3 | xargs -n 1 launchctl';
        context$1$0.prev = 7;
        stopCmd = launchCtlCommand + ' stop';
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', stopCmd]));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](7);

        _logger2['default'].warn('Could not stop ' + servicePattern + ' daemons, carrying on anyway!');

      case 16:
        context$1$0.prev = 16;
        removeCmd = launchCtlCommand + ' remove';
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', removeCmd]));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t1 = context$1$0['catch'](16);

        _logger2['default'].warn('Could not remove ' + servicePattern + ' daemons, carrying on anyway!');

      case 25:
        _i++;
        context$1$0.next = 3;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          var _ref, stdout;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', 'ps -e  | grep launchd_sim | grep -v bash | grep -v grep | awk {\'print$1\'}']));

              case 2:
                _ref = context$2$0.sent;
                stdout = _ref.stdout;
                return context$2$0.abrupt('return', stdout.trim().length === 0);

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, { waitMs: 5000, intervalMs: 500 }));

      case 31:
        context$1$0.next = 36;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t2 = context$1$0['catch'](28);

        _logger2['default'].warn('Could not end all simulator daemons, carrying on!');

      case 36:
        _logger2['default'].debug('Finishing ending all simulator daemons');

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 13], [16, 22], [28, 33]]);
}

function simExists(udid) {
  var devices;
  return _regeneratorRuntime.async(function simExists$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

      case 2:
        devices = context$1$0.sent;

        devices = _lodash2['default'].toPairs(devices).map(function (pair) {
          return pair[1];
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
        return context$1$0.abrupt('return', !!_lodash2['default'].find(devices, function (sim) {
          return sim.udid === udid;
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function safeRimRaf(delPath) {
  var tryNum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
  return _regeneratorRuntime.async(function safeRimRaf$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(delPath));

      case 3:
        context$1$0.next = 16;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(tryNum < 20)) {
          context$1$0.next = 16;
          break;
        }

        if (!(context$1$0.t0.message.indexOf('ENOTEMPTY') !== -1)) {
          context$1$0.next = 13;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\' was not empty during delete; retrying');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 13:
        if (!(context$1$0.t0.message.indexOf('ENOENT') !== -1)) {
          context$1$0.next = 16;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\'\' did not exist when we tried to delete, ignoring');
        return context$1$0.abrupt('return', safeRimRaf(delPath, tryNum + 1));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

function installSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function installSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('openssl'));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('customSSLCert requires openssl to be available on path');
        _logger2['default'].errorAndThrow('Command \'openssl\' not found');

      case 9:
        tempFileName = _path2['default'].resolve(__dirname, 'temp-ssl-cert.pem');
        pathToKeychain = new _simulatorXcode62['default'](udid).getDir();
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 13:
        context$1$0.prev = 13;
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(pathToKeychain));

      case 16:
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t1 = context$1$0['catch'](13);

        _logger2['default'].debug('Could not install SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t1);

      case 22:
        certificate = new _certificate.Certificate(tempFileName);
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(certificate.add(pathToKeychain));

      case 25:
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 27:
        return context$1$0.abrupt('return', certificate);

      case 28:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5], [13, 18]]);
}

function uninstallSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function uninstallSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        tempFileName = _path2['default'].resolve(__dirname, 'temp-ssl-cert.pem');
        pathToKeychain = _path2['default'].resolve(new _simulatorXcode62['default'](udid).getDir());
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 5:
        certificate = new _certificate.Certificate(tempFileName);
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(certificate.remove(pathToKeychain));

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 10:
        return context$1$0.abrupt('return', certificate);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Could not uninstall SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t0);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 13]]);
}

exports.killAllSimulators = killAllSimulators;
exports.endAllSimulatorDaemons = endAllSimulatorDaemons;
exports.safeRimRaf = safeRimRaf;
exports.simExists = simExists;
exports.installSSLCert = installSSLCert;
exports.uninstallSSLCert = uninstallSSLCert;

// wait for all the devices to be shutdown before Continuing
// but only print out the failed ones when they are actually fully failed

// waiting until the simulator service has died.

// see the README for github.com/appium/node-simctl for example output of getDevices()

// Check that openssl is installed on the path
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7c0JBQWdCLFVBQVU7Ozs7c0JBQ1osUUFBUTs7Ozs0QkFDRCxjQUFjOzt3QkFDRixVQUFVOzsyQkFDaEIsY0FBYzs7MEJBQ2QsYUFBYTs7NkJBQ3JCLGdCQUFnQjs7MkJBQ1AsZUFBZTs7b0JBQzFCLE1BQU07Ozs7K0JBQ0QscUJBQXFCOzs7O0FBRTNDLElBQU0saUJBQWlCLEdBQUcsS0FBSyxDQUFDOztBQUVoQyxTQUFlLGlCQUFpQjtNQUFFLE9BQU8seURBQUcsaUJBQWlCOztNQUd2RCxPQUFPLEVBQ1AsWUFBWSxFQVVWLFNBQVMsRUFlWCxnQkFBZ0IsRUFDTCxjQUFjLGtGQXdCaEIsTUFBTTs7Ozs7QUF4Qkosc0JBQWMsWUFBZCxjQUFjO2NBRXZCLE9BQU87Ozs7QUFEWCxnQ0FBZ0IsR0FBRyxFQUFFLENBQUM7O2lEQUNGLDZCQUFZOzs7QUFBNUIsdUJBQU87O0FBQ1gsdUJBQU8sR0FBRyxvQkFBRSxPQUFPLENBQUMsb0JBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7b0RBQ2hDLG9CQUFFLEtBQUssQ0FBQyxPQUFPLEVBQUUsVUFBQyxHQUFHLEVBQUs7QUFDL0Isc0JBQUksS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDcEMsc0JBQUksSUFBSSxHQUFHLEtBQUssS0FBSyxVQUFVLElBQ3BCLEtBQUssS0FBSyxhQUFhLElBQ3ZCLEtBQUssS0FBSyxjQUFjLENBQUM7QUFDcEMsc0JBQUksQ0FBQyxJQUFJLEVBQUU7QUFDVCxvQ0FBZ0IsQ0FBQyxJQUFJLENBQUMsOEJBQTRCLEdBQUcsQ0FBQyxJQUFJLFVBQUssR0FBRyxDQUFDLEdBQUcsaUJBQzdDLEdBQUcsQ0FBQyxJQUFJLDhCQUF3QixLQUFLLFFBQUcsQ0FBQyxDQUFDO21CQUNwRTtBQUNELHlCQUFPLElBQUksQ0FBQztpQkFDYixDQUFDOzs7Ozs7Ozs7QUEzQ0osNEJBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7O0FBRXBDLGVBQU87O3lDQUNjLDZCQUFXLElBQUksQ0FBQzs7O0FBQXJDLG9CQUFZOztBQUNoQixZQUFJLFlBQVksQ0FBQyxLQUFLLElBQUksQ0FBQyxFQUFFO0FBQzNCLGlCQUFPLEdBQUcsV0FBVyxDQUFDO1NBQ3ZCLE1BQU07QUFDTCxpQkFBTyxHQUFHLGVBQWUsQ0FBQztTQUMzQjs7Ozt5Q0FHTyx3QkFBSyxXQUFXLEVBQUUsQ0FBQyxJQUFJLGlCQUFlLE9BQU8sT0FBSSxFQUFFLEVBQUMsT0FBTyxFQUFQLE9BQU8sRUFBQyxDQUFDOzs7Ozs7Ozs7QUFFL0QsaUJBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxnQkFBRzs7YUFDN0IsU0FBUyxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQzs7Ozs7O0FBRTlDLDRCQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDOzs7OzthQUMzQyxlQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDOzs7Ozs7QUFFckMsNEJBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7O3lDQUN6RCx3QkFBSyxTQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7Ozs7OztBQUVoQyw0QkFBSSxhQUFhLGdCQUFHLENBQUM7OztBQU1yQix3QkFBZ0I7Ozt5Q0FrQlosZ0NBQWlCLGNBQWMsRUFBRTtBQUNyQyxnQkFBTSxFQUFFLEVBQUUsR0FBRyxJQUFJO0FBQ2pCLG9CQUFVLEVBQUUsR0FBRztTQUNoQixDQUFDOzs7Ozs7Ozs7O2NBRUUsZ0JBQWdCLElBQUksZ0JBQWdCLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQTs7Ozs7QUFDbkQsNEJBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7Ozs7O0FBQ2pFLHNDQUFtQixnQkFBZ0IscUdBQUU7QUFBNUIsZ0JBQU07O0FBQ2IsOEJBQUksS0FBSyxVQUFRLE1BQU0sQ0FBRyxDQUFDO1NBQzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FJTjs7QUFFRCxTQUFlLHNCQUFzQjtnQkFFMUIsY0FBYyxFQUVqQixnQkFBZ0IsRUFFZCxPQUFPLEVBTVAsU0FBUzs7Ozs7OztBQVhqQiw0QkFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztlQUNmLENBQUMsMkJBQTJCLEVBQUUseUJBQXlCLENBQUM7Ozs7Ozs7OztBQUExRSxzQkFBYzs7QUFDckIsNEJBQUksS0FBSyx3QkFBc0IsY0FBYyxjQUFXLENBQUM7QUFDckQsd0JBQWdCLDhCQUE0QixjQUFjOztBQUV4RCxlQUFPLEdBQU0sZ0JBQWdCOzt5Q0FDM0Isd0JBQUssTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBRW5DLDRCQUFJLElBQUkscUJBQW1CLGNBQWMsbUNBQWdDLENBQUM7Ozs7QUFHdEUsaUJBQVMsR0FBTSxnQkFBZ0I7O3lDQUM3Qix3QkFBSyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7Ozs7QUFFckMsNEJBQUksSUFBSSx1QkFBcUIsY0FBYyxtQ0FBZ0MsQ0FBQzs7Ozs7Ozs7Ozt5Q0FLeEUsZ0NBQWlCO29CQUNoQixNQUFNOzs7Ozs7aURBQVUsd0JBQUssTUFBTSxFQUFFLENBQUMsSUFBSSxnRkFDdUMsQ0FBQzs7OztBQUQxRSxzQkFBTSxRQUFOLE1BQU07b0RBRUosTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sS0FBSyxDQUFDOzs7Ozs7O1NBQ2xDLEVBQUUsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUMsQ0FBQzs7Ozs7Ozs7OztBQUVuQyw0QkFBSSxJQUFJLHFEQUFxRCxDQUFDOzs7QUFFaEUsNEJBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7Ozs7Ozs7Q0FDckQ7O0FBRUQsU0FBZSxTQUFTLENBQUUsSUFBSTtNQUV4QixPQUFPOzs7Ozt5Q0FBUyw2QkFBWTs7O0FBQTVCLGVBQU87O0FBRVgsZUFBTyxHQUFHLG9CQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQyxJQUFJLEVBQUs7QUFDekMsaUJBQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hCLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFLO0FBQ2xCLGlCQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDcEIsRUFBRSxFQUFFLENBQUMsQ0FBQzs0Q0FDQSxDQUFDLENBQUMsb0JBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxVQUFDLEdBQUcsRUFBSztBQUNoQyxpQkFBTyxHQUFHLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQztTQUMxQixDQUFDOzs7Ozs7O0NBQ0g7O0FBRUQsU0FBZSxVQUFVLENBQUUsT0FBTztNQUFFLE1BQU0seURBQUcsQ0FBQzs7Ozs7O3lDQUVwQyxrQkFBRyxNQUFNLENBQUMsT0FBTyxDQUFDOzs7Ozs7Ozs7O2NBRXBCLE1BQU0sR0FBRyxFQUFFLENBQUE7Ozs7O2NBQ1QsZUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBOzs7OztBQUN6Qyw0QkFBSSxLQUFLLGFBQVUsT0FBTyw4Q0FBMEMsQ0FBQzs0Q0FDOUQsVUFBVSxDQUFDLE9BQU8sRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDOzs7Y0FDN0IsZUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBOzs7OztBQUM3Qyw0QkFBSSxLQUFLLGFBQVUsT0FBTywwREFBcUQsQ0FBQzs0Q0FDekUsVUFBVSxDQUFDLE9BQU8sRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7O0NBSTdDOztBQUdELFNBQWUsY0FBYyxDQUFFLE9BQU8sRUFBRSxJQUFJO01BU3RDLFlBQVksRUFDWixjQUFjLEVBUWQsV0FBVzs7Ozs7O3lDQWZQLGtCQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7Ozs7Ozs7Ozs7QUFFekIsNEJBQUksS0FBSywwREFBMEQsQ0FBQztBQUNwRSw0QkFBSSxhQUFhLGlDQUErQixDQUFDOzs7QUFHL0Msb0JBQVksR0FBRyxrQkFBSyxPQUFPLENBQUMsU0FBUyxFQUFFLG1CQUFtQixDQUFDO0FBQzNELHNCQUFjLEdBQUcsaUNBQWMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFOzt5Q0FDM0Msa0JBQUcsU0FBUyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUM7Ozs7O3lDQUVqQyxrQkFBRyxJQUFJLENBQUMsY0FBYyxDQUFDOzs7Ozs7Ozs7O0FBRTdCLDRCQUFJLEtBQUssa0VBQStELElBQUksUUFBSSxDQUFDO0FBQ2pGLDRCQUFJLGFBQWEsZ0JBQUcsQ0FBQzs7O0FBRW5CLG1CQUFXLEdBQUcsNkJBQWdCLFlBQVksQ0FBQzs7eUNBQ3pDLFdBQVcsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDOzs7O3lDQUMvQixrQkFBRyxNQUFNLENBQUMsWUFBWSxDQUFDOzs7NENBQ3RCLFdBQVc7Ozs7Ozs7Q0FDbkI7O0FBRUQsU0FBZSxnQkFBZ0IsQ0FBRSxPQUFPLEVBQUUsSUFBSTtNQUV0QyxZQUFZLEVBQ1osY0FBYyxFQUVkLFdBQVc7Ozs7O0FBSFgsb0JBQVksR0FBRyxrQkFBSyxPQUFPLENBQUMsU0FBUyxFQUFFLG1CQUFtQixDQUFDO0FBQzNELHNCQUFjLEdBQUcsa0JBQUssT0FBTyxDQUFDLGlDQUFjLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDOzt5Q0FDekQsa0JBQUcsU0FBUyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUM7OztBQUNyQyxtQkFBVyxHQUFHLDZCQUFnQixZQUFZLENBQUM7O3lDQUN6QyxXQUFXLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQzs7Ozt5Q0FDbEMsa0JBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQzs7OzRDQUN0QixXQUFXOzs7Ozs7QUFFbEIsNEJBQUksS0FBSyxvRUFBaUUsSUFBSSxRQUFJLENBQUM7QUFDbkYsNEJBQUksYUFBYSxnQkFBRyxDQUFDOzs7Ozs7O0NBRXhCOztRQUVRLGlCQUFpQixHQUFqQixpQkFBaUI7UUFBRSxzQkFBc0IsR0FBdEIsc0JBQXNCO1FBQUUsVUFBVSxHQUFWLFVBQVU7UUFBRSxTQUFTLEdBQVQsU0FBUztRQUFFLGNBQWMsR0FBZCxjQUFjO1FBQUUsZ0JBQWdCLEdBQWhCLGdCQUFnQiIsImZpbGUiOiJsaWIvdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBnZXRWZXJzaW9uIH0gZnJvbSAnYXBwaXVtLXhjb2RlJztcbmltcG9ydCB7IGdldERldmljZXMgfSBmcm9tICdub2RlLXNpbWN0bCc7XG5pbXBvcnQgeyBmcyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IENlcnRpZmljYXRlIH0gZnJvbSAnLi9jZXJ0aWZpY2F0ZSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBTaW11bGF0b3IgZnJvbSAnLi9zaW11bGF0b3IteGNvZGUtNic7XG5cbmNvbnN0IE9TQVNDUklQVF9USU1FT1VUID0gMTAwMDA7XG5cbmFzeW5jIGZ1bmN0aW9uIGtpbGxBbGxTaW11bGF0b3JzICh0aW1lb3V0ID0gT1NBU0NSSVBUX1RJTUVPVVQpIHtcbiAgbG9nLmRlYnVnKCdLaWxsaW5nIGFsbCBpT1MgU2ltdWxhdG9ycycpO1xuXG4gIGxldCBhcHBOYW1lO1xuICBsZXQgeGNvZGVWZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbih0cnVlKTtcbiAgaWYgKHhjb2RlVmVyc2lvbi5tYWpvciA+PSA3KSB7XG4gICAgYXBwTmFtZSA9ICdTaW11bGF0b3InO1xuICB9IGVsc2Uge1xuICAgIGFwcE5hbWUgPSAnaU9TIFNpbXVsYXRvcic7XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IGV4ZWMoJ29zYXNjcmlwdCcsIFsnLWUnLCBgcXVpdCBhcHAgXCIke2FwcE5hbWV9XCJgXSwge3RpbWVvdXR9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxldCBlcnJTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShlKTtcbiAgICBpZiAoZXJyU3RyaW5nLm1hdGNoKC9BcHBsaWNhdGlvbiBpc24udCBydW5uaW5nLykpIHtcbiAgICAgIC8vIG9uIHNvbWUgc3lzdGVtcyB3ZSBnZXQgYW4gZXJyb3IgdGhhdCB0aGUgYXBwbGljYXRpb24gaXMgbm90IHJ1bm5pbmdcbiAgICAgIGxvZy5kZWJ1ZygnQXBwbGljYXRpb24gaXMgbm90IHJ1bm5pbmcuIENvbnRpbnVpbmcnKTtcbiAgICB9IGVsc2UgaWYgKGUubWVzc2FnZS5tYXRjaCgvdGltZWQgb3V0LykpIHtcbiAgICAgIC8vIHNvbWV0aW1lcywgZXNwZWNpYWxseSBpbiB4Y29kZSA4LCB0aGUgc2ltIGhhbmdzXG4gICAgICBsb2cuZGVidWcoJ0tpbGxpbmcgc2ltdWxhdG9yIHRpbWVkIG91dC4gVXNpbmcga2lsbGFsbCBzaWduYWwnKTtcbiAgICAgIGF3YWl0IGV4ZWMoJ2tpbGxhbGwnLCBbYXBwTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgICB9XG4gIH1cblxuICAvLyB3YWl0IGZvciBhbGwgdGhlIGRldmljZXMgdG8gYmUgc2h1dGRvd24gYmVmb3JlIENvbnRpbnVpbmdcbiAgLy8gYnV0IG9ubHkgcHJpbnQgb3V0IHRoZSBmYWlsZWQgb25lcyB3aGVuIHRoZXkgYXJlIGFjdHVhbGx5IGZ1bGx5IGZhaWxlZFxuICBsZXQgcmVtYWluaW5nRGV2aWNlcztcbiAgYXN5bmMgZnVuY3Rpb24gYWxsU2ltc0FyZURvd24gKCkge1xuICAgIHJlbWFpbmluZ0RldmljZXMgPSBbXTtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcbiAgICBkZXZpY2VzID0gXy5mbGF0dGVuKF8udmFsdWVzKGRldmljZXMpKTtcbiAgICByZXR1cm4gXy5ldmVyeShkZXZpY2VzLCAoc2ltKSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBzaW0uc3RhdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGxldCBkb25lID0gc3RhdGUgPT09ICdzaHV0ZG93bicgfHxcbiAgICAgICAgICAgICAgICAgc3RhdGUgPT09ICd1bmF2YWlsYWJsZScgfHxcbiAgICAgICAgICAgICAgICAgc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgIHJlbWFpbmluZ0RldmljZXMucHVzaChgU2ltdWxhdG9yIG5vdCBzaHV0IGRvd246ICR7c2ltLm5hbWV9ICgke3NpbS5zZGt9LCB1ZGlkOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3NpbS51ZGlkfSkgaXMgc3RpbGwgaW4gc3RhdGUgJyR7c3RhdGV9J2ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbmU7XG4gICAgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFsbFNpbXNBcmVEb3duLCB7XG4gICAgICB3YWl0TXM6IDYwICogMTAwMCxcbiAgICAgIGludGVydmFsTXM6IDIwMFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAocmVtYWluaW5nRGV2aWNlcyAmJiByZW1haW5pbmdEZXZpY2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbG9nLmVycm9yKCdUaGUgZm9sbG93aW5nIGRldmljZXMgYXJlIG5vdCBpbiB0aGUgY29ycmVjdCBzdGF0ZTonKTtcbiAgICAgIGZvciAobGV0IGRldmljZSBvZiByZW1haW5pbmdEZXZpY2VzKSB7XG4gICAgICAgIGxvZy5lcnJvcihgICAgICR7ZGV2aWNlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5kQWxsU2ltdWxhdG9yRGFlbW9ucyAoKSB7XG4gIGxvZy5kZWJ1ZygnRW5kaW5nIGFsbCBzaW11bGF0b3IgZGFlbW9ucycpO1xuICBmb3IgKGxldCBzZXJ2aWNlUGF0dGVybiBvZiBbJ2NvbS5hcHBsZS5pcGhvbmVzaW11bGF0b3InLCAnY29tLmFwcGxlLkNvcmVTaW11bGF0b3InXSkge1xuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhbnkgb3RoZXIgJHtzZXJ2aWNlUGF0dGVybn0gZGFlbW9uc2ApO1xuICAgIGxldCBsYXVuY2hDdGxDb21tYW5kID0gYGxhdW5jaGN0bCBsaXN0IHwgZ3JlcCAke3NlcnZpY2VQYXR0ZXJufSB8IGN1dCAtZiAzIHwgeGFyZ3MgLW4gMSBsYXVuY2hjdGxgO1xuICAgIHRyeSB7XG4gICAgICBsZXQgc3RvcENtZCA9IGAke2xhdW5jaEN0bENvbW1hbmR9IHN0b3BgO1xuICAgICAgYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLCBzdG9wQ21kXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgQ291bGQgbm90IHN0b3AgJHtzZXJ2aWNlUGF0dGVybn0gZGFlbW9ucywgY2Fycnlpbmcgb24gYW55d2F5IWApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHJlbW92ZUNtZCA9IGAke2xhdW5jaEN0bENvbW1hbmR9IHJlbW92ZWA7XG4gICAgICBhd2FpdCBleGVjKCdiYXNoJywgWyctYycsIHJlbW92ZUNtZF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCByZW1vdmUgJHtzZXJ2aWNlUGF0dGVybn0gZGFlbW9ucywgY2Fycnlpbmcgb24gYW55d2F5IWApO1xuICAgIH1cbiAgfVxuICAvLyB3YWl0aW5nIHVudGlsIHRoZSBzaW11bGF0b3Igc2VydmljZSBoYXMgZGllZC5cbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJyxcbiAgICAgICAgYHBzIC1lICB8IGdyZXAgbGF1bmNoZF9zaW0gfCBncmVwIC12IGJhc2ggfCBncmVwIC12IGdyZXAgfCBhd2sgeydwcmludCQxJ31gXSk7XG4gICAgICByZXR1cm4gc3Rkb3V0LnRyaW0oKS5sZW5ndGggPT09IDA7XG4gICAgfSwge3dhaXRNczogNTAwMCwgaW50ZXJ2YWxNczogNTAwfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBDb3VsZCBub3QgZW5kIGFsbCBzaW11bGF0b3IgZGFlbW9ucywgY2Fycnlpbmcgb24hYCk7XG4gIH1cbiAgbG9nLmRlYnVnKCdGaW5pc2hpbmcgZW5kaW5nIGFsbCBzaW11bGF0b3IgZGFlbW9ucycpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzaW1FeGlzdHMgKHVkaWQpIHtcbiAgLy8gc2VlIHRoZSBSRUFETUUgZm9yIGdpdGh1Yi5jb20vYXBwaXVtL25vZGUtc2ltY3RsIGZvciBleGFtcGxlIG91dHB1dCBvZiBnZXREZXZpY2VzKClcbiAgbGV0IGRldmljZXMgPSBhd2FpdCBnZXREZXZpY2VzKCk7XG5cbiAgZGV2aWNlcyA9IF8udG9QYWlycyhkZXZpY2VzKS5tYXAoKHBhaXIpID0+IHtcbiAgICByZXR1cm4gcGFpclsxXTtcbiAgfSkucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICB9LCBbXSk7XG4gIHJldHVybiAhIV8uZmluZChkZXZpY2VzLCAoc2ltKSA9PiB7XG4gICAgcmV0dXJuIHNpbS51ZGlkID09PSB1ZGlkO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2FmZVJpbVJhZiAoZGVsUGF0aCwgdHJ5TnVtID0gMCkge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLnJpbXJhZihkZWxQYXRoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHRyeU51bSA8IDIwKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignRU5PVEVNUFRZJykgIT09IC0xKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgUGF0aCAnJHtkZWxQYXRofScgd2FzIG5vdCBlbXB0eSBkdXJpbmcgZGVsZXRlOyByZXRyeWluZ2ApO1xuICAgICAgICByZXR1cm4gc2FmZVJpbVJhZihkZWxQYXRoLCB0cnlOdW0gKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignRU5PRU5UJykgIT09IC0xKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgUGF0aCAnJHtkZWxQYXRofScnIGRpZCBub3QgZXhpc3Qgd2hlbiB3ZSB0cmllZCB0byBkZWxldGUsIGlnbm9yaW5nYCk7XG4gICAgICAgIHJldHVybiBzYWZlUmltUmFmKGRlbFBhdGgsIHRyeU51bSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxTU0xDZXJ0IChwZW1UZXh0LCB1ZGlkKSB7XG4gIC8vIENoZWNrIHRoYXQgb3BlbnNzbCBpcyBpbnN0YWxsZWQgb24gdGhlIHBhdGhcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53aGljaCgnb3BlbnNzbCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBjdXN0b21TU0xDZXJ0IHJlcXVpcmVzIG9wZW5zc2wgdG8gYmUgYXZhaWxhYmxlIG9uIHBhdGhgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ29tbWFuZCAnb3BlbnNzbCcgbm90IGZvdW5kYCk7XG4gIH1cblxuICBsZXQgdGVtcEZpbGVOYW1lID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJ3RlbXAtc3NsLWNlcnQucGVtJyk7XG4gIGxldCBwYXRoVG9LZXljaGFpbiA9IG5ldyBTaW11bGF0b3IodWRpZCkuZ2V0RGlyKCk7XG4gIGF3YWl0IGZzLndyaXRlRmlsZSh0ZW1wRmlsZU5hbWUsIHBlbVRleHQpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLnN0YXQocGF0aFRvS2V5Y2hhaW4pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBDb3VsZCBub3QgaW5zdGFsbCBTU0wgY2VydGlmaWNhdGUuIE5vIHNpbXVsYXRvciB3aXRoIHVkaWQgJyR7dWRpZH0nYCk7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gIH1cbiAgbGV0IGNlcnRpZmljYXRlID0gbmV3IENlcnRpZmljYXRlKHRlbXBGaWxlTmFtZSk7XG4gIGF3YWl0IGNlcnRpZmljYXRlLmFkZChwYXRoVG9LZXljaGFpbik7XG4gIGF3YWl0IGZzLnVubGluayh0ZW1wRmlsZU5hbWUpO1xuICByZXR1cm4gY2VydGlmaWNhdGU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbFNTTENlcnQgKHBlbVRleHQsIHVkaWQpIHtcbiAgdHJ5IHtcbiAgICBsZXQgdGVtcEZpbGVOYW1lID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJ3RlbXAtc3NsLWNlcnQucGVtJyk7XG4gICAgbGV0IHBhdGhUb0tleWNoYWluID0gcGF0aC5yZXNvbHZlKG5ldyBTaW11bGF0b3IodWRpZCkuZ2V0RGlyKCkpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0ZW1wRmlsZU5hbWUsIHBlbVRleHQpO1xuICAgIGxldCBjZXJ0aWZpY2F0ZSA9IG5ldyBDZXJ0aWZpY2F0ZSh0ZW1wRmlsZU5hbWUpO1xuICAgIGF3YWl0IGNlcnRpZmljYXRlLnJlbW92ZShwYXRoVG9LZXljaGFpbik7XG4gICAgYXdhaXQgZnMudW5saW5rKHRlbXBGaWxlTmFtZSk7XG4gICAgcmV0dXJuIGNlcnRpZmljYXRlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBDb3VsZCBub3QgdW5pbnN0YWxsIFNTTCBjZXJ0aWZpY2F0ZS4gTm8gc2ltdWxhdG9yIHdpdGggdWRpZCAnJHt1ZGlkfSdgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBraWxsQWxsU2ltdWxhdG9ycywgZW5kQWxsU2ltdWxhdG9yRGFlbW9ucywgc2FmZVJpbVJhZiwgc2ltRXhpc3RzLCBpbnN0YWxsU1NMQ2VydCwgdW5pbnN0YWxsU1NMQ2VydCB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9

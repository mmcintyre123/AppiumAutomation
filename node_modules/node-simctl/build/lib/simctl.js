'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _appiumLogger = require('appium-logger');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var log = (0, _appiumLogger.getLogger)('simctl');

function simCommand(command, timeout) {
  var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var env = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  var executingFunction = arguments.length <= 4 || arguments[4] === undefined ? _teen_process.exec : arguments[4];
  return _regeneratorRuntime.async(function simCommand$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // run a particular simctl command
        args = ['simctl', command].concat(_toConsumableArray(args));
        // Prefix all passed in environment variables with 'SIMCTL_CHILD_', simctl
        // will then pass these to the child (spawned) process.
        env = _lodash2['default'].defaults(_lodash2['default'].mapKeys(env, function (value, key) {
          return 'SIMCTL_CHILD_' + key;
        }), process.env);

        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(executingFunction('xcrun', args, { timeout: timeout, env: env }));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](2);

        if (context$1$0.t0.stderr) {
          log.errorAndThrow('simctl error running \'' + command + '\': ' + context$1$0.t0.stderr.trim());
        } else {
          log.errorAndThrow(context$1$0.t0);
        }

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 8]]);
}

function simExec(command, timeout) {
  var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var env = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  return _regeneratorRuntime.async(function simExec$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simCommand(command, timeout, args, env, function callee$1$0(c, a, ob) {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(c, a, ob));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function simSubProcess(command, timeout) {
  var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
  var env = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  return _regeneratorRuntime.async(function simSubProcess$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simCommand(command, timeout, args, env, function callee$1$0(c, a, ob) {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                return context$2$0.abrupt('return', new _teen_process.SubProcess(c, a, ob));

              case 1:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function installApp(udid, appPath) {
  return _regeneratorRuntime.async(function installApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('install', 0, [udid, appPath]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function removeApp(udid, bundleId) {
  return _regeneratorRuntime.async(function removeApp$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('uninstall', 0, [udid, bundleId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function launch(udid, bundleId) {
  var tries = arguments.length <= 2 || arguments[2] === undefined ? 5 : arguments[2];
  return _regeneratorRuntime.async(function launch$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(tries, 1000, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(simExec('launch', 0, [udid, bundleId]));

              case 2:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3);
        }));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function spawn(udid, executablePath) {
  var env = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _regeneratorRuntime.async(function spawn$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('spawn', 0, [udid, executablePath], env));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function spawnSubProcess(udid, executablePath) {
  var env = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _regeneratorRuntime.async(function spawnSubProcess$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simSubProcess('spawn', 0, [udid, executablePath], env));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function openUrl(udid, url) {
  return _regeneratorRuntime.async(function openUrl$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('openurl', 0, [udid, url]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function shutdown(udid) {
  return _regeneratorRuntime.async(function shutdown$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('shutdown', 0, [udid]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function createDevice(name, deviceTypeId, runtimeId) {
  var timeout = arguments.length <= 3 || arguments[3] === undefined ? 10000 : arguments[3];
  var udid, out, retries;
  return _regeneratorRuntime.async(function createDevice$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        udid = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(simExec('create', 0, [name, deviceTypeId, runtimeId]));

      case 4:
        out = context$1$0.sent;

        udid = out.stdout.trim();
        context$1$0.next = 11;
        break;

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](1);

        if (context$1$0.t0.stderr) {
          log.errorAndThrow('Could not create simulator. Reason: ' + context$1$0.t0.stderr.trim());
        } else {
          log.errorAndThrow(context$1$0.t0);
        }

      case 11:
        retries = parseInt(timeout / 1000, 10);
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 1000, function callee$1$0() {
          var devices, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, deviceArr, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, device;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(getDevices());

              case 2:
                devices = context$2$0.sent;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 6;
                _iterator = _getIterator(_lodash2['default'].values(devices));

              case 8:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  context$2$0.next = 43;
                  break;
                }

                deviceArr = _step.value;
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                context$2$0.prev = 13;
                _iterator2 = _getIterator(deviceArr);

              case 15:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  context$2$0.next = 26;
                  break;
                }

                device = _step2.value;

                if (!(device.udid === udid)) {
                  context$2$0.next = 23;
                  break;
                }

                if (!(device.state === 'Creating')) {
                  context$2$0.next = 22;
                  break;
                }

                throw new Error('Device still being created');

              case 22:
                return context$2$0.abrupt('return');

              case 23:
                _iteratorNormalCompletion2 = true;
                context$2$0.next = 15;
                break;

              case 26:
                context$2$0.next = 32;
                break;

              case 28:
                context$2$0.prev = 28;
                context$2$0.t0 = context$2$0['catch'](13);
                _didIteratorError2 = true;
                _iteratorError2 = context$2$0.t0;

              case 32:
                context$2$0.prev = 32;
                context$2$0.prev = 33;

                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }

              case 35:
                context$2$0.prev = 35;

                if (!_didIteratorError2) {
                  context$2$0.next = 38;
                  break;
                }

                throw _iteratorError2;

              case 38:
                return context$2$0.finish(35);

              case 39:
                return context$2$0.finish(32);

              case 40:
                _iteratorNormalCompletion = true;
                context$2$0.next = 8;
                break;

              case 43:
                context$2$0.next = 49;
                break;

              case 45:
                context$2$0.prev = 45;
                context$2$0.t1 = context$2$0['catch'](6);
                _didIteratorError = true;
                _iteratorError = context$2$0.t1;

              case 49:
                context$2$0.prev = 49;
                context$2$0.prev = 50;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 52:
                context$2$0.prev = 52;

                if (!_didIteratorError) {
                  context$2$0.next = 55;
                  break;
                }

                throw _iteratorError;

              case 55:
                return context$2$0.finish(52);

              case 56:
                return context$2$0.finish(49);

              case 57:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4, [[6, 45, 49, 57], [13, 28, 32, 40], [33,, 35, 39], [50,, 52, 56]]);
        }));

      case 14:
        return context$1$0.abrupt('return', udid);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 8]]);
}

function deleteDevice(udid) {
  return _regeneratorRuntime.async(function deleteDevice$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('delete', 0, [udid]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function eraseDevice(udid) {
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? 1000 : arguments[1];
  var loopFn, retries;
  return _regeneratorRuntime.async(function eraseDevice$(context$1$0) {
    var _this5 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        loopFn = function loopFn() {
          return _regeneratorRuntime.async(function loopFn$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(simExec('erase', 10000, [udid]));

              case 2:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this5);
        };

        retries = parseInt(timeout / 200, 10);
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 200, loopFn));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getDevices() {
  var forSdk = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

  var _ref,
  // get the list of devices
  stdout, deviceSectionRe, matches, match, devices, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, sdk, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, line, lineRe, lineMatch;

  return _regeneratorRuntime.async(function getDevices$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(simExec('list', 0, ['devices']));

      case 2:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        deviceSectionRe = /-- iOS (.+) --(\n    .+)*/mg;
        matches = [];
        match = deviceSectionRe.exec(stdout);

        // make an entry for each sdk version
        while (match !== null) {
          matches.push(match);
          match = deviceSectionRe.exec(stdout);
        }
        if (matches.length < 1) {
          log.errorAndThrow('Could not find device section');
        }

        // get all the devices for each sdk
        devices = {};
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 13;
        _iterator3 = _getIterator(matches);

      case 15:
        if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
          context$1$0.next = 51;
          break;
        }

        match = _step3.value;
        sdk = match[1];

        devices[sdk] = [];
        // split the full match into lines and remove the first
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 22;
        _iterator4 = _getIterator(match[0].split('\n').slice(1));

      case 24:
        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
          context$1$0.next = 34;
          break;
        }

        line = _step4.value;
        lineRe = /([^\s].+) \((\w+-.+\w+)\) \((\w+\s?\w+)\)/;
        lineMatch = lineRe.exec(line);

        if (!(lineMatch === null)) {
          context$1$0.next = 30;
          break;
        }

        throw new Error('Could not match line: ' + line);

      case 30:
        // save the whole thing as ab object in the list for this sdk

        devices[sdk].push({
          name: lineMatch[1],
          udid: lineMatch[2],
          state: lineMatch[3],
          sdk: sdk
        });

      case 31:
        _iteratorNormalCompletion4 = true;
        context$1$0.next = 24;
        break;

      case 34:
        context$1$0.next = 40;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t0 = context$1$0['catch'](22);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 40:
        context$1$0.prev = 40;
        context$1$0.prev = 41;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 43:
        context$1$0.prev = 43;

        if (!_didIteratorError4) {
          context$1$0.next = 46;
          break;
        }

        throw _iteratorError4;

      case 46:
        return context$1$0.finish(43);

      case 47:
        return context$1$0.finish(40);

      case 48:
        _iteratorNormalCompletion3 = true;
        context$1$0.next = 15;
        break;

      case 51:
        context$1$0.next = 57;
        break;

      case 53:
        context$1$0.prev = 53;
        context$1$0.t1 = context$1$0['catch'](13);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t1;

      case 57:
        context$1$0.prev = 57;
        context$1$0.prev = 58;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 60:
        context$1$0.prev = 60;

        if (!_didIteratorError3) {
          context$1$0.next = 63;
          break;
        }

        throw _iteratorError3;

      case 63:
        return context$1$0.finish(60);

      case 64:
        return context$1$0.finish(57);

      case 65:
        if (!forSdk) {
          context$1$0.next = 69;
          break;
        }

        if (devices[forSdk]) {
          context$1$0.next = 68;
          break;
        }

        throw new Error('Sdk \'' + forSdk + '\' was not in list of simctl sdks');

      case 68:
        return context$1$0.abrupt('return', devices[forSdk]);

      case 69:
        return context$1$0.abrupt('return', devices);

      case 70:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[13, 53, 57, 65], [22, 36, 40, 48], [41,, 43, 47], [58,, 60, 64]]);
}

exports.installApp = installApp;
exports.removeApp = removeApp;
exports.launch = launch;
exports.spawn = spawn;
exports.spawnSubProcess = spawnSubProcess;
exports.openUrl = openUrl;
exports.shutdown = shutdown;
exports.createDevice = createDevice;
exports.deleteDevice = deleteDevice;
exports.eraseDevice = eraseDevice;
exports.getDevices = getDevices;

// make sure that it gets out of the "Creating" state

// need to retry

// stop looking, we're done

// retry erase with a sleep in between because it's flakey

// expect to get a listing like
// -- iOS 8.1 --
//     iPhone 4s (3CA6E7DD-220E-45E5-B716-1E992B3A429C) (Shutdown)
//     ...
// -- iOS 8.2 --
//     iPhone 4s (A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E) (Shutdown)
//     ...
// so, get the `-- iOS X.X --` line to find the sdk (X.X)
// and the rest of the listing in order to later find the devices

// a line is something like
//    iPhone 4s (A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E) (Shutdown)
// retrieve:
//   iPhone 4s
//   A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E
//   Shutdown
// https://regex101.com/r/lG7mK6/3

// if a `forSdk` was passed in, return only the corresponding list

// otherwise return all the sdk -> device mappings.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zaW1jdGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7NEJBQWlDLGNBQWM7O3dCQUNqQixVQUFVOzs0QkFDZCxlQUFlOztzQkFDM0IsUUFBUTs7OztBQUd0QixJQUFNLEdBQUcsR0FBRyw2QkFBVSxRQUFRLENBQUMsQ0FBQzs7QUFFaEMsU0FBZSxVQUFVLENBQUUsT0FBYyxFQUFFLE9BQWM7TUFBRSxJQUFVLHlEQUFHLEVBQUU7TUFBRSxHQUFHLHlEQUFHLEVBQUU7TUFBRSxpQkFBaUI7Ozs7O0FBRXJHLFlBQUksSUFBSSxRQUFRLEVBQUUsT0FBTyw0QkFBSyxJQUFJLEVBQUMsQ0FBQzs7O0FBR3BDLFdBQUcsR0FBRyxvQkFBRSxRQUFRLENBQUMsb0JBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxVQUFTLEtBQUssRUFBRSxHQUFHLEVBQUU7QUFDbkQsbUNBQXVCLEdBQUcsQ0FBRztTQUM5QixDQUFDLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7O3lDQUdGLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFFLEdBQUcsRUFBSCxHQUFHLEVBQUMsQ0FBQzs7Ozs7Ozs7O0FBRTdELFlBQUksZUFBRSxNQUFNLEVBQUU7QUFDWixhQUFHLENBQUMsYUFBYSw2QkFBMEIsT0FBTyxZQUFNLGVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFHLENBQUM7U0FDNUUsTUFBTTtBQUNMLGFBQUcsQ0FBQyxhQUFhLGdCQUFHLENBQUM7U0FDdEI7Ozs7Ozs7Q0FFSjs7QUFFRCxTQUFlLE9BQU8sQ0FBRSxPQUFjLEVBQUUsT0FBYztNQUFFLElBQVUseURBQUcsRUFBRTtNQUFFLEdBQUcseURBQUcsRUFBRTs7Ozs7Ozt5Q0FDbEUsVUFBVSxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxvQkFBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Ozs7O2lEQUNyRCx3QkFBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQzs7Ozs7Ozs7OztTQUM1QixDQUFDOzs7Ozs7Ozs7O0NBQ0g7O0FBRUQsU0FBZSxhQUFhLENBQUUsT0FBYyxFQUFFLE9BQWM7TUFBRSxJQUFVLHlEQUFHLEVBQUU7TUFBRSxHQUFHLHlEQUFHLEVBQUU7Ozs7Ozs7eUNBQ3hFLFVBQVUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsb0JBQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFOzs7O29EQUMzRCw2QkFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQzs7Ozs7OztTQUNoQyxDQUFDOzs7Ozs7Ozs7O0NBQ0g7O0FBRUQsU0FBZSxVQUFVLENBQUUsSUFBVyxFQUFFLE9BQWM7Ozs7O3lDQUM5QyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7Ozs7OztDQUM3Qzs7QUFFRCxTQUFlLFNBQVMsQ0FBRSxJQUFXLEVBQUUsUUFBZTs7Ozs7eUNBQzlDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDOzs7Ozs7O0NBQ2hEOztBQUVELFNBQWUsTUFBTSxDQUFFLElBQVcsRUFBRSxRQUFlO01BQUUsS0FBUyx5REFBRyxDQUFDOzs7Ozs7O3lDQUMxRCw2QkFBYyxLQUFLLEVBQUUsSUFBSSxFQUFFOzs7OztpREFDekIsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7Ozs7Ozs7U0FDN0MsQ0FBQzs7Ozs7OztDQUNIOztBQUVELFNBQWUsS0FBSyxDQUFFLElBQVcsRUFBRSxjQUFxQjtNQUFFLEdBQUcseURBQUcsRUFBRTs7Ozs7eUNBQ25ELE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxFQUFFLEdBQUcsQ0FBQzs7Ozs7Ozs7OztDQUM5RDs7QUFFRCxTQUFlLGVBQWUsQ0FBRSxJQUFXLEVBQUUsY0FBcUI7TUFBRSxHQUFHLHlEQUFHLEVBQUU7Ozs7O3lDQUM3RCxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsRUFBRSxHQUFHLENBQUM7Ozs7Ozs7Ozs7Q0FDcEU7O0FBRUQsU0FBZSxPQUFPLENBQUUsSUFBVyxFQUFFLEdBQVU7Ozs7O3lDQUNoQyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7OztDQUNoRDs7QUFFRCxTQUFlLFFBQVEsQ0FBRSxJQUFXOzs7Ozt5Q0FDNUIsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7Ozs7OztDQUNyQzs7QUFFRCxTQUFlLFlBQVksQ0FBRSxJQUFXLEVBQUUsWUFBbUIsRUFDekQsU0FBZ0I7TUFBRSxPQUFXLHlEQUFHLEtBQUs7TUFDbkMsSUFBSSxFQUVGLEdBQUcsRUFZTCxPQUFPOzs7Ozs7QUFkUCxZQUFJOzs7eUNBRVUsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDOzs7QUFBakUsV0FBRzs7QUFDUCxZQUFJLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7Ozs7Ozs7QUFFekIsWUFBSSxlQUFFLE1BQU0sRUFBRTtBQUNaLGFBQUcsQ0FBQyxhQUFhLDBDQUF3QyxlQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBRyxDQUFDO1NBQzdFLE1BQU07QUFDTCxhQUFHLENBQUMsYUFBYSxnQkFBRyxDQUFDO1NBQ3RCOzs7QUFLQyxlQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sR0FBRyxJQUFJLEVBQUUsRUFBRSxDQUFDOzt5Q0FDcEMsNkJBQWMsT0FBTyxFQUFFLElBQUksRUFBRTtjQUM3QixPQUFPLGtGQUNGLFNBQVMsdUZBQ1AsTUFBTTs7Ozs7O2lEQUZHLFVBQVUsRUFBRTs7O0FBQTVCLHVCQUFPOzs7Ozt5Q0FDVyxvQkFBRSxNQUFNLENBQUMsT0FBTyxDQUFDOzs7Ozs7OztBQUE5Qix5QkFBUzs7Ozs7MENBQ0csU0FBUzs7Ozs7Ozs7QUFBbkIsc0JBQU07O3NCQUNULE1BQU0sQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFBOzs7OztzQkFDbEIsTUFBTSxDQUFDLEtBQUssS0FBSyxVQUFVLENBQUE7Ozs7O3NCQUV2QixJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQVF0RCxDQUFDOzs7NENBRUssSUFBSTs7Ozs7OztDQUNaOztBQUVELFNBQWUsWUFBWSxDQUFFLElBQVc7Ozs7O3lDQUNoQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7Ozs7O0NBQ25DOztBQUVELFNBQWUsV0FBVyxDQUFFLElBQVc7TUFBRSxPQUFXLHlEQUFHLElBQUk7TUFDckQsTUFBZSxFQUlmLE9BQU87Ozs7OztBQUpQLGNBQWUsR0FBRyxTQUFsQixNQUFlOzs7OztpREFDWCxPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7Ozs7O1NBQ3RDOztBQUVHLGVBQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxHQUFHLEdBQUcsRUFBRSxFQUFFLENBQUM7O3lDQUNuQyw2QkFBYyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQzs7Ozs7OztDQUMxQzs7QUFFRCxTQUFlLFVBQVU7TUFBRSxNQUFhLHlEQUFHLElBQUk7Ozs7QUFFeEMsUUFBTSxFQVdQLGVBQXNCLEVBQ3RCLE9BQWEsRUFDYixLQUFZLEVBWVosT0FBYyx1RkFFWixHQUFVLHVGQUdMLElBQVcsRUFPZCxNQUFhLEVBQ2IsU0FBZ0I7Ozs7Ozt5Q0F0Q0gsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQzs7OztBQUEvQyxjQUFNLFFBQU4sTUFBTTtBQVdQLHVCQUFzQixHQUFHLDZCQUE2QjtBQUN0RCxlQUFhLEdBQUcsRUFBRTtBQUNsQixhQUFZLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7OztBQUcvQyxlQUFPLEtBQUssS0FBSyxJQUFJLEVBQUU7QUFDckIsaUJBQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDcEIsZUFBSyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDdEM7QUFDRCxZQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLGFBQUcsQ0FBQyxhQUFhLENBQUMsK0JBQStCLENBQUMsQ0FBQztTQUNwRDs7O0FBR0csZUFBYyxHQUFHLEVBQUU7Ozs7O2tDQUNULE9BQU87Ozs7Ozs7O0FBQWhCLGFBQUs7QUFDSixXQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQzs7QUFDekIsZUFBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQzs7Ozs7O2tDQUVNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7QUFBNUMsWUFBVztBQU9kLGNBQWEsR0FBRywyQ0FBMkM7QUFDM0QsaUJBQWdCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7O2NBQ3BDLFNBQVMsS0FBSyxJQUFJLENBQUE7Ozs7O2NBQ2QsSUFBSSxLQUFLLDRCQUEwQixJQUFJLENBQUc7Ozs7O0FBSWxELGVBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDaEIsY0FBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsY0FBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsZUFBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsYUFBRyxFQUFILEdBQUc7U0FDSixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQUtILE1BQU07Ozs7O1lBQ0gsT0FBTyxDQUFDLE1BQU0sQ0FBQzs7Ozs7Y0FDWixJQUFJLEtBQUssWUFBUyxNQUFNLHVDQUFtQzs7OzRDQUU1RCxPQUFPLENBQUMsTUFBTSxDQUFDOzs7NENBSWpCLE9BQU87Ozs7Ozs7Q0FDZjs7UUFFUSxVQUFVLEdBQVYsVUFBVTtRQUFFLFNBQVMsR0FBVCxTQUFTO1FBQUUsTUFBTSxHQUFOLE1BQU07UUFBRSxLQUFLLEdBQUwsS0FBSztRQUFFLGVBQWUsR0FBZixlQUFlO1FBQUUsT0FBTyxHQUFQLE9BQU87UUFBRSxRQUFRLEdBQVIsUUFBUTtRQUFFLFlBQVksR0FBWixZQUFZO1FBQ3RGLFlBQVksR0FBWixZQUFZO1FBQUUsV0FBVyxHQUFYLFdBQVc7UUFBRSxVQUFVLEdBQVYsVUFBVSIsImZpbGUiOiJsaWIvc2ltY3RsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnYXBwaXVtLWxvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbmNvbnN0IGxvZyA9IGdldExvZ2dlcignc2ltY3RsJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIHNpbUNvbW1hbmQgKGNvbW1hbmQ6c3RyaW5nLCB0aW1lb3V0Om51bWJlciwgYXJnczpBcnJheSA9IFtdLCBlbnYgPSB7fSwgZXhlY3V0aW5nRnVuY3Rpb24gPSBleGVjKSB7XG4gIC8vIHJ1biBhIHBhcnRpY3VsYXIgc2ltY3RsIGNvbW1hbmRcbiAgYXJncyA9IFsnc2ltY3RsJywgY29tbWFuZCwgLi4uYXJnc107XG4gIC8vIFByZWZpeCBhbGwgcGFzc2VkIGluIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aXRoICdTSU1DVExfQ0hJTERfJywgc2ltY3RsXG4gIC8vIHdpbGwgdGhlbiBwYXNzIHRoZXNlIHRvIHRoZSBjaGlsZCAoc3Bhd25lZCkgcHJvY2Vzcy5cbiAgZW52ID0gXy5kZWZhdWx0cyhfLm1hcEtleXMoZW52LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGBTSU1DVExfQ0hJTERfJHtrZXl9YDtcbiAgfSksIHByb2Nlc3MuZW52KTtcblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleGVjdXRpbmdGdW5jdGlvbigneGNydW4nLCBhcmdzLCB7dGltZW91dCwgZW52fSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5zdGRlcnIpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBzaW1jdGwgZXJyb3IgcnVubmluZyAnJHtjb21tYW5kfSc6ICR7ZS5zdGRlcnIudHJpbSgpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2ltRXhlYyAoY29tbWFuZDpzdHJpbmcsIHRpbWVvdXQ6bnVtYmVyLCBhcmdzOkFycmF5ID0gW10sIGVudiA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBzaW1Db21tYW5kKGNvbW1hbmQsIHRpbWVvdXQsIGFyZ3MsIGVudiwgYXN5bmMgKGMsIGEsIG9iKSA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IGV4ZWMoYywgYSwgb2IpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2ltU3ViUHJvY2VzcyAoY29tbWFuZDpzdHJpbmcsIHRpbWVvdXQ6bnVtYmVyLCBhcmdzOkFycmF5ID0gW10sIGVudiA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBzaW1Db21tYW5kKGNvbW1hbmQsIHRpbWVvdXQsIGFyZ3MsIGVudiwgYXN5bmMgKGMsIGEsIG9iKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTdWJQcm9jZXNzKGMsIGEsIG9iKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxBcHAgKHVkaWQ6c3RyaW5nLCBhcHBQYXRoOnN0cmluZyk6dm9pZCB7XG4gIGF3YWl0IHNpbUV4ZWMoJ2luc3RhbGwnLCAwLCBbdWRpZCwgYXBwUGF0aF0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZW1vdmVBcHAgKHVkaWQ6c3RyaW5nLCBidW5kbGVJZDpzdHJpbmcpOnZvaWQge1xuICBhd2FpdCBzaW1FeGVjKCd1bmluc3RhbGwnLCAwLCBbdWRpZCwgYnVuZGxlSWRdKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbGF1bmNoICh1ZGlkOnN0cmluZywgYnVuZGxlSWQ6c3RyaW5nLCB0cmllczppbnQgPSA1KTp2b2lkIHtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbCh0cmllcywgMTAwMCwgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNpbUV4ZWMoJ2xhdW5jaCcsIDAsIFt1ZGlkLCBidW5kbGVJZF0pO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc3Bhd24gKHVkaWQ6c3RyaW5nLCBleGVjdXRhYmxlUGF0aDpzdHJpbmcsIGVudiA9IHt9KTp2b2lkIHtcbiAgcmV0dXJuIGF3YWl0IHNpbUV4ZWMoJ3NwYXduJywgMCwgW3VkaWQsIGV4ZWN1dGFibGVQYXRoXSwgZW52KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc3Bhd25TdWJQcm9jZXNzICh1ZGlkOnN0cmluZywgZXhlY3V0YWJsZVBhdGg6c3RyaW5nLCBlbnYgPSB7fSk6dm9pZCB7XG4gIHJldHVybiBhd2FpdCBzaW1TdWJQcm9jZXNzKCdzcGF3bicsIDAsIFt1ZGlkLCBleGVjdXRhYmxlUGF0aF0sIGVudik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9wZW5VcmwgKHVkaWQ6c3RyaW5nLCB1cmw6c3RyaW5nKTp2b2lkIHtcbiAgcmV0dXJuIGF3YWl0IHNpbUV4ZWMoJ29wZW51cmwnLCAwLCBbdWRpZCwgdXJsXSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNodXRkb3duICh1ZGlkOnN0cmluZyk6dm9pZCB7XG4gIGF3YWl0IHNpbUV4ZWMoJ3NodXRkb3duJywgMCwgW3VkaWRdKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGV2aWNlIChuYW1lOnN0cmluZywgZGV2aWNlVHlwZUlkOnN0cmluZyxcbiAgICBydW50aW1lSWQ6c3RyaW5nLCB0aW1lb3V0OmludCA9IDEwMDAwKTp2b2lkIHtcbiAgbGV0IHVkaWQ7XG4gIHRyeSB7XG4gICAgbGV0IG91dCA9IGF3YWl0IHNpbUV4ZWMoJ2NyZWF0ZScsIDAsIFtuYW1lLCBkZXZpY2VUeXBlSWQsIHJ1bnRpbWVJZF0pO1xuICAgIHVkaWQgPSBvdXQuc3Rkb3V0LnRyaW0oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLnN0ZGVycikge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYENvdWxkIG5vdCBjcmVhdGUgc2ltdWxhdG9yLiBSZWFzb246ICR7ZS5zdGRlcnIudHJpbSgpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhlKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IGl0IGdldHMgb3V0IG9mIHRoZSBcIkNyZWF0aW5nXCIgc3RhdGVcbiAgbGV0IHJldHJpZXMgPSBwYXJzZUludCh0aW1lb3V0IC8gMTAwMCwgMTApO1xuICBhd2FpdCByZXRyeUludGVydmFsKHJldHJpZXMsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IGdldERldmljZXMoKTtcbiAgICBmb3IgKGxldCBkZXZpY2VBcnIgb2YgXy52YWx1ZXMoZGV2aWNlcykpIHtcbiAgICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VBcnIpIHtcbiAgICAgICAgaWYgKGRldmljZS51ZGlkID09PSB1ZGlkKSB7XG4gICAgICAgICAgaWYgKGRldmljZS5zdGF0ZSA9PT0gJ0NyZWF0aW5nJykge1xuICAgICAgICAgICAgLy8gbmVlZCB0byByZXRyeVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXZpY2Ugc3RpbGwgYmVpbmcgY3JlYXRlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9wIGxvb2tpbmcsIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB1ZGlkO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZWxldGVEZXZpY2UgKHVkaWQ6c3RyaW5nKTp2b2lkIHtcbiAgYXdhaXQgc2ltRXhlYygnZGVsZXRlJywgMCwgW3VkaWRdKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXJhc2VEZXZpY2UgKHVkaWQ6c3RyaW5nLCB0aW1lb3V0OmludCA9IDEwMDApOnZvaWQge1xuICBsZXQgbG9vcEZuOkZ1bmN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNpbUV4ZWMoJ2VyYXNlJywgMTAwMDAsIFt1ZGlkXSk7XG4gIH07XG4gIC8vIHJldHJ5IGVyYXNlIHdpdGggYSBzbGVlcCBpbiBiZXR3ZWVuIGJlY2F1c2UgaXQncyBmbGFrZXlcbiAgbGV0IHJldHJpZXMgPSBwYXJzZUludCh0aW1lb3V0IC8gMjAwLCAxMCk7XG4gIGF3YWl0IHJldHJ5SW50ZXJ2YWwocmV0cmllcywgMjAwLCBsb29wRm4pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXREZXZpY2VzIChmb3JTZGs6c3RyaW5nID0gbnVsbCk6T2JqZWN0IHtcbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGRldmljZXNcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgc2ltRXhlYygnbGlzdCcsIDAsIFsnZGV2aWNlcyddKTtcblxuICAvLyBleHBlY3QgdG8gZ2V0IGEgbGlzdGluZyBsaWtlXG4gIC8vIC0tIGlPUyA4LjEgLS1cbiAgLy8gICAgIGlQaG9uZSA0cyAoM0NBNkU3REQtMjIwRS00NUU1LUI3MTYtMUU5OTJCM0E0MjlDKSAoU2h1dGRvd24pXG4gIC8vICAgICAuLi5cbiAgLy8gLS0gaU9TIDguMiAtLVxuICAvLyAgICAgaVBob25lIDRzIChBOTlGRkZDMy04RTE5LTREQ0YtQjU4NS03RDlENDZCNEMxNkUpIChTaHV0ZG93bilcbiAgLy8gICAgIC4uLlxuICAvLyBzbywgZ2V0IHRoZSBgLS0gaU9TIFguWCAtLWAgbGluZSB0byBmaW5kIHRoZSBzZGsgKFguWClcbiAgLy8gYW5kIHRoZSByZXN0IG9mIHRoZSBsaXN0aW5nIGluIG9yZGVyIHRvIGxhdGVyIGZpbmQgdGhlIGRldmljZXNcbiAgbGV0IGRldmljZVNlY3Rpb25SZTpSZWdFeHAgPSAvLS0gaU9TICguKykgLS0oXFxuICAgIC4rKSovbWc7XG4gIGxldCBtYXRjaGVzOkFycmF5ID0gW107XG4gIGxldCBtYXRjaDpPYmplY3QgPSBkZXZpY2VTZWN0aW9uUmUuZXhlYyhzdGRvdXQpO1xuXG4gIC8vIG1ha2UgYW4gZW50cnkgZm9yIGVhY2ggc2RrIHZlcnNpb25cbiAgd2hpbGUgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICBtYXRjaCA9IGRldmljZVNlY3Rpb25SZS5leGVjKHN0ZG91dCk7XG4gIH1cbiAgaWYgKG1hdGNoZXMubGVuZ3RoIDwgMSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KCdDb3VsZCBub3QgZmluZCBkZXZpY2Ugc2VjdGlvbicpO1xuICB9XG5cbiAgLy8gZ2V0IGFsbCB0aGUgZGV2aWNlcyBmb3IgZWFjaCBzZGtcbiAgbGV0IGRldmljZXM6T2JqZWN0ID0ge307XG4gIGZvciAobWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBzZGs6c3RyaW5nID0gbWF0Y2hbMV07XG4gICAgZGV2aWNlc1tzZGtdID0gW107XG4gICAgLy8gc3BsaXQgdGhlIGZ1bGwgbWF0Y2ggaW50byBsaW5lcyBhbmQgcmVtb3ZlIHRoZSBmaXJzdFxuICAgIGZvciAobGV0IGxpbmU6c3RyaW5nIG9mIG1hdGNoWzBdLnNwbGl0KCdcXG4nKS5zbGljZSgxKSkge1xuICAgICAgLy8gYSBsaW5lIGlzIHNvbWV0aGluZyBsaWtlXG4gICAgICAvLyAgICBpUGhvbmUgNHMgKEE5OUZGRkMzLThFMTktNERDRi1CNTg1LTdEOUQ0NkI0QzE2RSkgKFNodXRkb3duKVxuICAgICAgLy8gcmV0cmlldmU6XG4gICAgICAvLyAgIGlQaG9uZSA0c1xuICAgICAgLy8gICBBOTlGRkZDMy04RTE5LTREQ0YtQjU4NS03RDlENDZCNEMxNkVcbiAgICAgIC8vICAgU2h1dGRvd25cbiAgICAgIGxldCBsaW5lUmU6UmVnRXhwID0gLyhbXlxcc10uKykgXFwoKFxcdystLitcXHcrKVxcKSBcXCgoXFx3K1xccz9cXHcrKVxcKS87IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvbEc3bUs2LzNcbiAgICAgIGxldCBsaW5lTWF0Y2g6T2JqZWN0ID0gbGluZVJlLmV4ZWMobGluZSk7XG4gICAgICBpZiAobGluZU1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IG1hdGNoIGxpbmU6ICR7bGluZX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIHNhdmUgdGhlIHdob2xlIHRoaW5nIGFzIGFiIG9iamVjdCBpbiB0aGUgbGlzdCBmb3IgdGhpcyBzZGtcblxuICAgICAgZGV2aWNlc1tzZGtdLnB1c2goe1xuICAgICAgICBuYW1lOiBsaW5lTWF0Y2hbMV0sXG4gICAgICAgIHVkaWQ6IGxpbmVNYXRjaFsyXSxcbiAgICAgICAgc3RhdGU6IGxpbmVNYXRjaFszXSxcbiAgICAgICAgc2RrLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBgZm9yU2RrYCB3YXMgcGFzc2VkIGluLCByZXR1cm4gb25seSB0aGUgY29ycmVzcG9uZGluZyBsaXN0XG4gIGlmIChmb3JTZGspIHtcbiAgICBpZiAoIWRldmljZXNbZm9yU2RrXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZGsgJyR7Zm9yU2RrfScgd2FzIG5vdCBpbiBsaXN0IG9mIHNpbWN0bCBzZGtzYCk7XG4gICAgfVxuICAgIHJldHVybiBkZXZpY2VzW2ZvclNka107XG4gIH1cblxuICAvLyBvdGhlcndpc2UgcmV0dXJuIGFsbCB0aGUgc2RrIC0+IGRldmljZSBtYXBwaW5ncy5cbiAgcmV0dXJuIGRldmljZXM7XG59XG5cbmV4cG9ydCB7IGluc3RhbGxBcHAsIHJlbW92ZUFwcCwgbGF1bmNoLCBzcGF3biwgc3Bhd25TdWJQcm9jZXNzLCBvcGVuVXJsLCBzaHV0ZG93biwgY3JlYXRlRGV2aWNlLFxuICAgICAgICAgZGVsZXRlRGV2aWNlLCBlcmFzZURldmljZSwgZ2V0RGV2aWNlcyB9O1xuIl19